'Version 2.5 for CR6 + CDM-A116 + 2 CSAT3B + slow microclimate sensors, based on EasyFlux_DL for CR6
'ADAPTED FOR TWO CSAT3D_B, Sensible flux only und additional sensors by AlpuG GmbH, H. Gubler Nov. 2019

'Requirements:
'              CR6   OS version 09.02 or newer
'              CDM-A100 OS version .04 or newer
'              CRBasic editor for revision (Revised under any other text editor may not compile)

'Copyright (c), 2019 Campbell Scientific, Alpug GMBH
'This program is intended for use with Campbell Scientific CSAT3B ( two)
'along with microclimate sensors.
'The most common or â€œbest practiceâ€ corrections are applied to fluxes in this program.  Consult the manual for details on these corrections.  It is the responsibility
'of the user to determine appropriateness of the corrections used. Campbell Scientific always recommends saving raw time series data in case reprocessing of raw data
'is warranted. Furthermore, it is the responsibility of the user and associated researchers to determine the quality and fitness of any and all data,
'regardless of whether said data were processed by this program or another tool.

'* SITE AND CALIBRATION CONSTANTS
' Search for the text string "Unique" in this code to find the lines below in this program where "Unique" site constants and sensor calibration constants are entered.


'Sensors:
'csat3B_A
'Csat3B_B
'CNR4
'CS100 Barometer
'8 NTC Ice Temp JB 1
'8 NTC Ice Temp JB 2
'T/RH Hygrovue10 used for RH measurement
'Tair T107 used for T107 measurement
'SR50a Snowheight sensor

'Parameters to be ajusted to actual values after system mounting  *************************************************************

'Const SHM_H   (default 300, cm) mounting height of sensor head
'Const T107PR_OFST   As Float     = 0        'Unique: offset for T1o7 Air temperature, multiplier = 1

'Const SENSOR_CNR4 As Boolean   = true       'Unique: CNR4 4-way net radiometer.
'Const SW_IN_SNSTVT As Float    = 12.90      'Unique: NR01/CNR4 sensitivity of upward facing pyranometer as reported on sensor calibration sheet [uV/(W m-2)]
'Const SWOUT_SNSTVT As Float    = 14.79      'Unique: NR01/CNR4 sensitivity of downward facing pyranometer as reported on sensor calibration sheet [uV/(W m-2)]
'Const LW_IN_SNSTVT As Float    = 14.53       'Unique: NR01/CNR4 sensitivity of upward facing pyrgeometer as reported on sensor calibration sheet [uV/(W m-2)]
'Const LWOUT_SNSTVT As Float    = 13.72       'Unique: NR01/CNR4 sensitivity of downward facing pyrgeometer as reported on sensor calibration sheet [uV/(W m-2)]

' SONIC ANEMOMETER_A and _B
' Const CSAT3B_A  As Boolean = true            'Unique: CSAT3B. lower device
' Const CSAT3B_B  As Boolean = true            '        CSAT3B_B. upper device


'*Pressure GAGE
'Const SENSOR_23S  As Boolean = True         'Unique: Water pressure sensor
'Water flow Gauge
'Const SENSOR_WFlow As Boolean  = True       'Unique: Flow gauge

'NTC Ice temp: Calibration offset array Tice_OFST()
'Const SENSOR_Icetemp_JB1 As Boolean = true  'Unique: NTC JB1
'Const SENSOR_Icetemp_JB2 As Boolean = false  'Unique: NTC JB2

' Const clatitude = 46.694990               ' Schwarzsee
' Const clongitude = 7.299775
' Const caltitude = 968.0

'  eddy corr
' "Meas Height",   height_measurement   (m)
' "Meas HeightB",   height_measurementB   (m)
' "Surface Type", surface_type   1..7 CROP, GRASS, FOREST, SHRUB, BARELAND, WATER, ICE  default 7
' "Canopy Height", height_canopy  )(m)
' "d, 0 = auto",   displacement_user                        'if 0, zero displacement is automatically calculated in the program
' "z0,0 = auto",   roughness_user                           'if 0, roughness length is automatically calculated in the program

' "Sonic Azmth", sonic_azimuth  see manual and theory  adj into prevailing wind dir....., never behind strucures in prevailing wind directions
' "Sonic AzmthB", sonic_azimuthB   from true north, + counterclockwise


'********************************************
'*** USER-DEFINED CONFIGURATION CONSTANTS ***
'********************************************

'Start of Constants Customization Section
ConstTable (Const_Table)

  '*PROGRAM FUNCTION CONSTANTS
  Const SCN_INTV                 = 100         'Unique: measurement rate (ms): 40 ms (25 Hz), 50 ms (20 Hz), 100 ms (10 Hz) as Default, 200 ms (5 Hz), or 1000 ms (1 Hz)
  Const SLW_SCN_INTV             = 5000        'Unique: slow sequence measurement rate (ms) >3000 ms and <6000ms (Note: SDI-12 sensors too slow for sub-second intervals). (5000 as Default)
  Const OUTPUT_INTV              = 30          'Unique: online flux data output interval (minutes). (30 as Default)
  Const DAY_FLUX_CRD             = 30          'Unique: number of days of Flux_CSFormat, Flux_Notes table data to store in each file on the card. Number of files stored depends on card size. (30 as Default)
  Const DAY_TSRS_CRD             = 1           'Unique: number of days of Time_Series table data to store in each file on the card. Number of files stored depends on card size.
  Const NTCH_FRQ_SLW As Long     = 50          'Unique: slowsequence analog measurement integration time, 60 for 60Hz (e.g. in US, Canada, etc.) or 50 for 50Hz (e.g. in Europe, China, etc.)
  Const ONE_FL_TABLE As Boolean  = FALSE       'Unique: Whether or not all half-hourly or hourly data in Flux_CSFormat and Flux_Notes are stored in one table (FALSE as default).
  Const Version = 2.5

  '*PERIPHERAL
  Const DVC_CDM_A116 As Boolean  = TRUE        'Unique: A CDM-A116 is being used with the CR6 (FALSE as default. Required for NTC ice measurement sensors).
  Const CDM_SN       As Long     = 9401        'Unique: CDM-A116 serial number
  Const CPI_ADDR_CDM As Long     = 1           'Unique: CPI address for CDM-A116
  Const CPI_DEVICE   As String   = "CDMA116"   'Unique: CDM Module name or identifier

  '*  SONIC ANEMOMETER_A and _B
  Const CSAT3B_A  As Boolean = true            'Unique: CSAT3B. lower device
  Const CSAT3B_B  As Boolean = true            '        CSAT3B_B. upper device
  ' Const SDM_CLCK_SPD  As Long    = 30        'Unique: 30 is default SDM clock speed (uS). May need to increase if using long cables and skipped scans are observed. NU
  Const CSAT3B_A_CPI_ADDR As Long  = 10        'Unique: SDM address for EC100.
  Const CSAT3B_B_CPI_ADDR As Long  = 11
  Const BANDWIDTH                = 20          'Unique: in Hz. For spectral analysis, set to 1/2 sampling freq. Options: 5, 10, 12.5, 20, or 25 Hz. For flux only, set 20 Hz (Default) if sampling freq is 10 Hz
  Const UTC_OFST                 = 1          'Unique: The local standard time, in hours, from UTC/GMT.

  '*TEMP/RH PROBE
  Const SENSOR_T_RH As Boolean   = true       'Unique: Hygrovue10 SDI12.
  Const SENSOR_T_RH_SDIAdr As Boolean   = 1   'SDI12 address
  Const SENSOR_T107 As Boolean   = true       'T107 Airtemp sensor
  Const TMPR_MULT   As Float     =  1         'Unique: multiplier for temperature
  Const TMPR_OFST   As Float     = 0          'Unique: offset for temperature
  Const RH_MULT     As Float     =   1        'Unique: multiplier for RH
  Const RH_OFST     As Float     =   0.0      'Unique: offset for RH
  Const T107PR_OFST   As Float     = 0        'Unique: offset for T1o7 Air temperature, multiplier = 1


  '*Pressure GAGE
  Const SENSOR_23S  As Boolean = True         'Unique: Water pressure sensor
  'Water flow Gauge
  Const SENSOR_WFlow As Boolean  = True       'Unique: Flow gauge

  '*NR01/CNR4/SN500 4-WAY NET RADIOMETER
  Const SENSOR_CNR4 As Boolean   = true       'Unique: CNR4 4-way net radiometer.
  Const SW_IN_SNSTVT As Float    = 12.90      'Unique: NR01/CNR4 sensitivity of upward facing pyranometer as reported on sensor calibration sheet [uV/(W m-2)]
  Const SWOUT_SNSTVT As Float    = 14.79      'Unique: NR01/CNR4 sensitivity of downward facing pyranometer as reported on sensor calibration sheet [uV/(W m-2)]
  Const LW_IN_SNSTVT As Float    = 14.53       'Unique: NR01/CNR4 sensitivity of upward facing pyrgeometer as reported on sensor calibration sheet [uV/(W m-2)]
  Const LWOUT_SNSTVT As Float    = 13.72       'Unique: NR01/CNR4 sensitivity of downward facing pyrgeometer as reported on sensor calibration sheet [uV/(W m-2)]

  'SR50a snow height
  Const SENSOR_SR50a As Boolean   = true      'Unique: SR50a
  Const SHM_H = 200                            'SR50a Mounting height in cm

  'NTC Ice temp: Calibration offset array Tice_OFST()
  Const SENSOR_Icetemp_JB1 As Boolean = true  'Unique: NTC JB1
  Const SENSOR_Icetemp_JB2 As Boolean = false  'Unique: NTC JB2

  Const Sensor_CS100 As Boolean = true
  Const clatitude = 46.6953404               ' Schwarzsee
  Const clongitude = 7.2999946
  Const caltitude = 968.0


  'End of Constants Customization Section
EndConstTable
'* Composite Boolean variables for variables above
Const SENSOR_Rn            = SENSOR_CNR4
Const SCAN_INTERVAL_WEIGHT = SLW_SCN_INTV/(60*1000*OUTPUT_INTV)           'Used to calculate the fraction of day time in an scan interval

'***************************************************
'*** END OF USER-DEFINED CONFIGURATION CONSTANTS ***
'***************************************************

'*******************************************
'*** DEFAULT SETTING FOR CR6 AND PROGRAM ***
'*******************************************
PipeLineMode
AngleDegrees         'Angle degree used throughout the program

'*** END of DEFAULT SETTING FOR CR6 AND PROGRAM ***


'***********************************************
'*** ABBREVIATIONS IN COMMENTS AND VARIABLES ***
'***********************************************
'AG     analog ground
'amb    ambient
'CSAT   CSAT3B
'cumul  cumulative
'deg    degree
'dia    diameter
'diag   diagnostic
'dir    direction
'dist   distance
'f      flag (information or program control, dim variable)
'flg    flag (user interactive flag, public variable)
'FP     footprint
'Freq   frequency
'frac   fraction
'FTPRNT footprint
'G      ground (i.e. power ground)
'intrst interest
'nmbr   number
'pct    percent
'press  Pressure
'Pyran  pyranometer
'RH     relative humidity
'rng    range
'QC     quality control or quality classification
'sig    signal
'strgth strength
'win    within
'wnd    wind
'wtr    water


'*******************************
'*** NOTES AND EXPLANATIONS ***
'*******************************
'* SIGN CONVENTION
' Positive fluxes are away from the ground surface, and negative towards the ground surface.

'************************
'*** UNIT DEFINITIONS ***
'************************
'SYMBOL      UNIT
'C           Celsius
'degrees     angle degrees
'frac_v_wtr  Fraction volumetric water content
'g           grams
'J           Joules
'Hz          Hertz
'kg          kilograms
'kPa         kilopascals
'm           meters
'mg          milligrams
'ms          milliseconds
's           seconds
'usec        microseconds
'V           volts
'W           Watts
'*** UNIT DEFINITIONS ***


'**************************
'*** WIRING INSTRUCTIONS ***
'***************************

'*** Beginning of Power Supply Wiring ***
'CR6 BAT +     Positive of 12Vdc battery or external power supply
'CR6 BAT -     Negative of 12Vdc battery or external power supply

'*** Beginning of CSatB_A and _B Wiring ***
'CR6 Daisy chain on PCI input
'SW12V_1  fuse1 to CSAT3B_A and_B daisy chain
'G    Power reference
'*** End of VCSAT3B Wiring ***

'*** Beginning of T107 Air Temp + Hygrovue10 SDI12 wiring ***
'CR6 U2   Temperature signal T107 ref resist to AG
'CR6 U3   Exitation T107
'CR6 C3   SDI12 Hygrovue10 address 1
'CR6 C3   SDI12 SR50a address 0
'12V  Power Fuse 2
'G    Power reference
'*** End of T107 Air Temp + Hygrovue10 wiring ***

'*** Beginning of CDM-A116 Wiring to CR6 ***
' CR6 CPI port                               CDM-A116 CPI PORT (Use Cat5 or Cat6 Ethernet cable)
' Positive of power supply or CR6 BAT +      CDM-A116 12V
' Negative of power supply or CR6 BAT -      CDM-A116 G
'*** End of CDM-A116 Wiring to CR6 ***

'SE analog input channel in CR6 to measure body temperature and 4-way radiation sensor.
Const SW_IN_CAL  = 1000/SW_IN_SNSTVT           'Multiplier for NR01/CNR4 shortwave downwelling (incoming) radiation [w/(m^2 mV)].
Const SW_OUT_CAL = 1000/SWOUT_SNSTVT           'Multiplier for NR01/CNR4 shortwave upwelling (outgoing) radiation [w/(m^2 mV)].
Const LW_IN_CAL  = 1000/LW_IN_SNSTVT           'Multiplier for NR01/CNR4 longwave downwelling (incoming) radiation [w/(m^2 mV)].
Const LW_OUT_CAL = 1000/LWOUT_SNSTVT           'Multiplier for NR01/CNR4 longwave upwelling (outgoing) radiation [w/(m^2 mV)].

'*** Beginning of CNR4 wiring ***
'Cable 1
' CR6 U9     Downwelling (incoming) shortwave radiation signal (red)
' AG         Downwelling (incoming) shortwave radiation signal reference (blue)
' CR6 U10    Upwelling (outgoing) shortwave radiation signal (white)
' AG         Upwelling (outgoing) shortwave radiation signal reference (black)
' CR6 U11    Downwelling (incoming) longwave radiation signal (grey)
' AG         Downwelling (incoming) longwave radiation signal reference (yellow)
' CR6 U12    Upwelling (outgoing) longwave radiation signal (brown)
' AG         Upwelling (outgoing) longwave radiation signal reference (green)

'Cable 2
' CR6 U7 4H     Thermistor signal (white)
'  AG           Thermistor signal reference (black)
'  AG           Shield (clear)
' CR6 U8        Thermistor voltage excitation (red)
'*** End of CNR4 wiring ***

'*** SR50a wiring ****
' CR6 C3 SDI12 Address2
' 12V  Power Fuse 2

'*** wiring NTC JBox 1
'CDM_A116 SE1 - SE 8  Temperature signal 1-8, ref resist to AG
'CDM_A116 EX1
'*** wiring NTC JBox 2
'CDM_A116 SE9 - SE16  Temperature signal 1-8, ref resist to AG
'CDM_A116 EX2

'*** Pressure Keller 23S***
'CR6 U2  Signal 0 - 25000mV  (Blitzschutzklemme)
'Sicherung3  power 12V

'*** Air Pressure CS100***
'CR6 U1  Analog Signal
'Sicherung2  power 12V

'*** Water Flow Digmesa DT2020***
'CR6 C2  Pulse 5V   (Blitzschutzklemme)
'Sicherung3  power 12V

'*** END OF WIRING INSTRUCTIONS ***

'*************************************************
'*** BEGINNING OF STATION CONSTANTS AND VARIABLES ***
'*************************************************
Const NMBR_DAY_CPU     = 7                                          'Number of days of flux data to store on the CPU.
Const FLUX_SIZE_CPU    = Ceiling ((NMBR_DAY_CPU*1440)/OUTPUT_INTV)  'Number of records that are in NMBR_DAY_CPU [(days*1440 minutes/day)/(minutes/record)] = records].
Const SCAN_BUFFER_SIZE = 290*INT (2000/SCN_INTV) *( 1- CSAT3B_B)    'Compute a 290-second scan buffer (The buffer is less than 5 minutes because of 5-minute interval for QC-computational data tables.
Const FIRST_NOTCH_FREQ_MAIN_SCAN = 50                               'Measurement integration frequency. Filters 50Hz rippel
'***Variables used to estimate the number of days for MicroSD to be continuously used
Public card_bytes_free                                              'Free bytes of MicroSD in bytes
Dim    card_bytes_free_assgnd                                       'Free bytes of MicroSD that were assigned for more DataTable
Dim    card_bytes_free_unassgnd                                     'Free bytes of MicroSD were not asigned for more DataTables
Dim    day_snc_0101_1990                                            'Days since Jan 01, 1990.

'Time_Series Table whose size is pre-allocated.
Dim bytes_rcd_Time_Series                                           'Bytes used in MicroSD for each record of Time_Series table
Dim bytes_tbl_Time_Series                                           'Bytes used in MicroSD for one Time_Series table whose size in days is defined by a user
Dim days_actv_tbl_Time_Series                                       'Days of free bytes inside active Time_Series table
Dim days_more_tbl_Time_Series                                       'Days of free bytes for more Time_Series table
Dim days_totl_tbl_Time_Series                                       'Total days of free bytes possibly used Time_Series table

Public LastFileName_Time_Series      As String *36 = NaN            'Used to monitor the completion of Time_Series datatable
Public LastFileName_Time_SeriesB     As String *36 = NaN            'NOT USED
Dim    LastFileName_Time_Series_prev As String *36 = NaN

'Flux table in CS format whose size is pre-allocated.
Dim bytes_rcd_flux_CSFormat                                         'Bytes used in MicroSD for each record of flux table in CSFormat
Dim bytes_tbl_flux_CSFormat                                         'Bytes used in MicroSD for one Flux_CSFormat table whose size in days is defined by a user
'Flux notes table whose size is pre-allocated.
Dim bytes_rcd_flux_notes                                            'Bytes used in MicroSD for each record of Flux_CSFormat table
Dim bytes_tbl_flux_notes                                            'Bytes used in MicroSD for one Flux_CSFormat table whose size in days is defined by a user
Dim days_actv_tbl_flux_CSFormat_notes                               'Days of free bytes inside active Flux_CSFormat and Flux_notes tables
Dim days_more_tbl_flux_CSFormat_notes                               'Days of free bytes for more Flux_CSFormat and Flux_notes tables
Dim days_totl_tbl_flux_CSFormat_notes                               'Total days of free bytes possibly used for Flux_CSFormat and Flux_notes tables
Public LastFileName_flux_CSFormat       As String *36               'Used to monitor the completion of Flux_in CSFormat table
Public LastFileName_fluxB_CSFormat      As String *36               'NOT USED IN SPACE CALC, table A is always written
Public LastFileName_flux_CSFormat_prev  As String *36

Public card_storage_available_days                                  'The number of extra days for MicroSD to store more data. This variable will be referenced by EasyFlux_web
Units  card_storage_available_days = days

'Variables for constructing time stamp in AmeriFlux format Not used but may be implemented in flau tables if necessary
Dim CR6_clock As String *22
Public TimeStamp_AmeriFluxFormat(2) As String *12
Alias TimeStamp_AmeriFluxFormat(1) = TIMESTAMP_START
Alias TimeStamp_AmeriFluxFormat(2) = TIMESTAMP_END

Dim stn_conf_array_file      As Long             'Filehandle for the configuration data stored in the CPU.
Dim stn_conf_array_file_size As Long             'Size of the station configuration file stored on the CPU.

Dim stnB_conf_array_file      As Long             'Filehandle for the configuration data stored in the CPU.
Dim stnB_conf_array_file_size As Long

Const NMBR_STN_VAR       = (17)   'Number of station variables below


Public stn_conf_array(NMBR_STN_VAR)              'These station parameters are entered using the datalogger keypad while program is running after compiled.
Alias stn_conf_array(1)  = sonic_azimuth         'Azimuth angle (degrees) (see Section 3.1.1 CSAT3B Azimuth in the OPEC manual).
Alias stn_conf_array(2)  = latitude              'Latitude (degrees)
Alias stn_conf_array(3)  = hemisphere_NS         '"1" for north and "-1" for south, following GPS convention
Alias stn_conf_array(4)  = longitude             'Longitude (degrees)
Alias stn_conf_array(5)  = hemisphere_EW         '"1" for east and "-1" for west, following GPS convention
Alias stn_conf_array(6)  = altitude              'Altitude (m)
Alias stn_conf_array(7)  = height_measurement    'Measurement height (m)
Alias stn_conf_array(8)  = surface_type          'crop = 1, grass = 2, forest = 3, shrub = 4, bare land = 5, and water = 6, ice = 7
Alias stn_conf_array(9)  = height_canopy         'canopy height (m).
Alias stn_conf_array(10) = displacement_user     'User-entered displacement height (m) [If 0 (default), then auto calculate]
Alias stn_conf_array(11) = roughness_user        'User-entered roughness length (m) [If 0 (default), then auto calculate and continuously updated by recalculation when netrual stratification]


Units sonic_azimuth       = Decimal degrees
Units latitude            = Decimal degrees
Units hemisphere_NS       = adimensional         '"adimensional" indicates no units (i.e dimensionless)
Units longitude           = Decimal degrees
Units hemisphere_EW       = adimensional         '"adimensional" indicates no units (i.e. dimensionless)
Units altitude            = m
Units height_measurement  = m
Units surface_type        = adimensional         '"adimensional" indicates no unit (i.e. dimensionless)
Units height_canopy       = m
Units displacement_user   = m
Units roughness_user      = m

#If CSAT3B_B Then

  Public stnB_conf_array(NMBR_STN_VAR)              'These station parameters are entered using the datalogger keypad while program is running after compiled.
  Alias stnB_conf_array(1)  = sonic_azimuthB         'Azimuth angle (degrees) (see Section 3.1.1 CSAT3B Azimuth in the OPEC manual).
  Alias stnB_conf_array(2)  = latitudeB              'Latitude (degrees)
  Alias stnB_conf_array(3)  = hemisphere_NSB         '"1" for north and "-1" for south, following GPS convention
  Alias stnB_conf_array(4)  = longitudeB             'Longitude (degrees)
  Alias stnB_conf_array(5)  = hemisphere_EWB         '"1" for east and "-1" for west, following GPS convention
  Alias stnB_conf_array(6)  = altitudeB              'Altitude (m)
  Alias stnB_conf_array(7)  = height_measurementB    'Measurement height (m)
  Alias stnB_conf_array(8)  = surface_typeB          'crop = 1, grass = 2, forest = 3, shrub = 4, bare land = 5, and water = 6
  Alias stnB_conf_array(9)  = height_canopyB         'canopy height (m).
  Alias stnB_conf_array(10) = displacement_userB     'User-entered displacement height (m) [If 0 (default), then auto calculate]
  Alias stnB_conf_array(11) = roughness_userB
  Units sonic_azimuthB       = Decimal degrees
  Units latitudeB            = Decimal degrees
  Units hemisphere_NSB       = adimensional         '"adimensional" indicates no units (i.e dimensionless)
  Units longitudeB           = Decimal degrees
  Units hemisphere_EWB       = adimensional         '"adimensional" indicates no units (i.e. dimensionless)
  Units altitudeB            = m
  Units height_measurementB  = m
  Units surface_typeB        = adimensional         '"adimensional" indicates no unit (i.e. dimensionless)
  Units height_canopyB       = m
  Units displacement_userB   = m
  Units roughness_userB      = m
#EndIf

Dim stn_conf_array_prev(NMBR_STN_VAR)                     'Hold previous station parameters to check for new user-entered values
Dim stnB_conf_array_prev(NMBR_STN_VAR)

'After user inputs, used to assign a sign to latitude and longitude
Const NORTH =  1
Const SOUTH = -1
Const EAST  =  1
Const WEST  = -1

'Used to assign a value for surface_type
Const CROP     = 1
Const GRASS    = 2
Const FOREST   = 3
Const SHRUB    = 4
Const BARELAND = 5
Const WATER    = 6
Const ICE      = 7

Dim surface_type_array(7) As String * 9 = {"Crop", "Grass", "Forest", "Shrub", "Bare land", "Water", "Ice"}
Dim surface_type_text     As String * 9   'Used to record the surface type in data table

'*** END OF STATION CONSTANTS AND VARIABLES ***

'*** Variables for solar position ***
Public solar_position_array(5)
Alias solar_position_array(1) = sun_azimuth
Alias solar_position_array(2) = sun_elevation
Alias solar_position_array(3) = hour_angle
Alias solar_position_array(4) = sun_declination
Alias solar_position_array(5) = air_mass_coeff
Units sun_azimuth     = decimal degrees
Units sun_elevation   = decimal degrees
Units hour_angle      = decimal degrees
Units sun_declination = decimal degrees
Units air_mass_coeff  = adimensional

Public daytime As Long             'Day = 1 and night = 0
Dim    daytime_frac_scan_intv      'To calculate the day time fraction in an output interval using Totalize instruction
Units  daytime_frac_scan_intv = fraction

'*** End of variables for solar position ***

'*** BEGINNING OF REAL TIME VARIABLES ***
Dim realtime_array(9)             'Hold real time to calculated the time length of the 1st time averaging interval that starts anytime
'*** END OF REAL TIME VARIABLES ***

'*****************************************************************
'*** BEGINNING CONSTANTS AND VARIABLES FOR ATMOSPHERIC PHYSICS ***
'*** [Unless noted, see page 467 in Wallace AND Hobbs (2006)]  ***
'*****************************************************************

Const Cpd     = 1004.0             'specific heat of dry air at constant pressure [J/(kg K)]
Const Cpw     = 1952.0             'specific heat of water vapor at constant pressure [J/(kg K)]
Const Cw      = 4218.0             'specific heat of liquid water at 0 C [J/(kg K)]
Const epsilon = 18.016/28.97       'molecular mass ratio of water vapor to dry air
Const g0      = 9.81               'acceleration due to gravity at sea level (m/s^2)
Const k       = 0.41               'von Karman constant (Dyer & Hicker 1970, Webb 1970)
Const MU_WPL  = 28.97/18.016       'molecular mass ratio of dry air to water vapor (used in WPL correction)
Const Omega   = 7.292e-5           'Angular velocity of the earth for calculation of Coriolis Force (2PI/sidreal_day, where sidereal day = 23 hr 56 min. [rad/s]
Const R       = 8.3143e-3          'Universal gas constant [kPa m^3/(K mol)]
Const Rd      = R/28.97            'Gas constant for dry air [kPa m^3/(K g)]
Const Rv      = R/18.016           'Gas constant for water vapor [kPa m^3/(K g)]
Const PI      = 3.1415926          'Pi (just use the seven digits after decimal, commonly used)
Const Sigma_SB= 5.6718e-8          'Stefan-Boltzmann constant in air [J/(K^4 m^2 s), see page 336 in McGee (1988)]
Const T_0C_K  = 273.15             'Temperature in K at 0 degree C

Public Cp                          'specific heat of moist air at constant pressure calc from RH probe
Units  Cp = J kg-1 deg C-1

'*** END OF CONSTANTS AND VARIABLES FOR ATMOSPHERIC PHYSICS ******

'*******************************************
'*** BEGIN PROGRAM WORKING VARIABLES ***
'*******************************************
Dim scan_count                 As Long       'Number scans executed. Working variable used to judge the scan loop, from which data processing starts.

Dim slowsequence_finished_f   As Boolean     'Flag used to indicate that the slowSequence has finished its scan.
Dim slowsequence_disable_f    As Boolean     'Flag used to decimate statistics in main scan.

Dim i, i_slow As Long        'Index variables for the outmost loop. "i" in main scan and "i_slow" in slow scan sequence

Dim n As Long = 1                            'Used to count the number of samples
Units n = samples

Dim nB As Long = 1                            'Used to count the number of samples
Units nB = samples

Dim dly_data_out(8)
Dim dly_data_outB(8)                          'Array used to temporarily store the lagged record from the raw data table (hidden)

Dim x_tmp                                    'Temporary variable used in intermediate calculations
Dim process_time                             'Used to monitor processing time and reported in flux_notes table
Units process_time = ms                      'Converted from us to ms that is easy to read

Dim buff_depth                               'Used to monitor buffer depth and reported in flux_notes table
Units buff_depth = scans
'*** END OF PROGRAM WORKING VARIABLES ***


'*******************************************************
'*** BEGIN DATALOGGER SELF-MEASUREMENT VARIABLES ***
'*******************************************************
Public panel_tmpr                                          'CR6 panel temperature
Units  panel_tmpr = deg C
Public flaginit As Boolean

'*** Beginning of CDM-A116 panel temperature ***
Public panel_tmpr_CDM_A116(4)
Alias  panel_tmpr_CDM_A116(1) = panel_tmpr_CDM_A116_1      'CDM-A116 panel temperature #1
Alias  panel_tmpr_CDM_A116(2) = panel_tmpr_CDM_A116_2      'CDM-A116 panel temperature #2
Alias  panel_tmpr_CDM_A116(3) = panel_tmpr_CDM_A116_3      'CDM-A116 panel temperature #3
Alias  panel_tmpr_CDM_A116(4) = panel_tmpr_CDM_A116_4      'CDM-A116 panel temperature #4
'*** End of CDM-A116 panel temperature ***

Public batt_volt                                           'Voltage of power connected to CR6
Units  batt_volt  = V
'*** END OF DATALOGGER SELF-MEASUREMENT VARIABLES ***


'*******************************************************
'*** BEGINNING OF CORRECTION CONSTANTS AND VARIABLES ***
'*******************************************************
' Rotation angles from the instrument to the natural flow coordinate system. Notations are consistent with Wilczak et al (2001)
Public alpha                                'Angle of counterclockwise rotation about y-axis (pitch)
Public beta                                 'Angle of counterclockwise rotation about x-axis (roll)
Public gamma                                'Angle of counterclockwise rotation about z-axis (yaw)
Units  alpha = Decimal degrees
Units  beta  = Decimal degrees
Units  gamma = Decimal degrees
Public alphaB                                'Angle of counterclockwise rotation about y-axis (pitch)
Public betaB                                 'Angle of counterclockwise rotation about x-axis (roll)
Public gammaB
Public alpha_5min                            '5-minute data for data QC. Angle of counterclockwise rotation about y-axis (pich)
Public beta_5min                             '5-minute data for data QC. Angle of counterclockwise rotation about x-axis (roll)
Public gamma_5min
Public alphaB_5min                            '5-minute data for data QC. Angle of counterclockwise rotation about y-axis (pich)
Public betaB_5min                             '5-minute data for data QC. Angle of counterclockwise rotation about x-axis (roll)
Public gammaB_5min                            '5-minute data for data QC. Angle of counterclockwise rotation about z-axis (yaw)
Units  alpha_5min = Decimal degrees
Units  beta_5min  = Decimal degrees
Units  gamma_5min = Decimal degrees


' Program chooses conventional rotation of Tanner and Thurtell (1969) if the following eight angles are all zero.

Public Planar_Fit_flg As Boolean               'False always

' Atmospheric stability
Public MO_LENGTH, MO_LENGTHB                    'Monin-Obukhov length (m)
Public PBLH, PBLHB                              'planetary boundary layer height (m)
Public d, dB                                    'displacement height (m)
Public z0,z0B                                   'roughness length (m)
Public z,zB                                     'aerodynamic height: z = measurement height - d  (m)
Dim    z_prev, zB_prev                          'Previous z, used to judge whether or not the distance of interest needs to be re-evaluated
Public ZL,ZLB                                   'atmospheric surface-layer stability (dimensionless)
Dim    ZL_prev ,ZLB_prev                        'previous ZL (dimensionless)
Units  MO_LENGTH  = m
Units  PBLH       = m
Units  d          = m
Units  z0         = m
Units  z          = m
Units  ZL         = adimensional
Units  MO_LENGTHB  = m
Units  PBLHB       = m
Units  dB          = m
Units  z0B         = m
Units  zB          = m
Units  ZLB         = adimensional

' Constants used for numerical integration in calculating the freq correction factors
Const START_FREQ           = 10e-6     'Starting cyclic freq for numerical integration of cospectrum times transfer function
Const END_FREQ             = 10000.0   'Ending cyclic freq for numerical integration of cospectrum times transfer function
Const FREQ_BIN             = 100.0     'The number of bins for cyclic freq
Const STEP_BASE_FREQ       = EXP((LN(END_FREQ)- LN(START_FREQ))/FREQ_BIN)   'freq interval base for numerical integration of cospectra and transfer functions (e.g. 100 bins from 0.000001 to 10000 Hz).
Const ACCURACY_FREQ_FACTOR = 0.0001    'The accuracy target of freq factor to approach the "true" value (|current freq factor - previous freq factor|) [page 106: Foken et al. (2012)]
Const MAX_LAG              = 5         'Maximum number of lags in scans that is used to maximizing the covariance. This number of 2 is believed to be adequate for CSAT with EC150 and/or FW


' Frequency (freq) correction
Public iteration_FreqFactor As Long                             'count iterations while correcting wu, wv, and wTs for accurate Monin-Obukhov length
Public FreqFactor_UW_VW         = 1                            'freq correction factor for covariance of vertical with horizontal wind that are measured using CSAT
Dim    FreqFactor_UW_VW_Prev    = 1 - 2*ACCURACY_FREQ_FACTOR   'previous FreqFactor_UW_VW
Public FreqFactor_WT_SONIC      = 1                            'freq correction factor for covariance of vertical wind with sonic temperature that are measured using CSAT
Dim    FreqFactor_WT_SONIC_Prev = 1 - 2*ACCURACY_FREQ_FACTOR   'previous FreqFactor_WT_SONIC
Units FreqFactor_UW_VW     = adimensional
Units FreqFactor_WT_SONIC  = adimensional
#If CSAT3B_B
  ' Frequency (freq) correctionB
  Public iteration_FreqFactorB As Long
  Public FreqFactorB_UW_VW         = 1                            'freq correction factor for covariance of vertical with horizontal wind that are measured using CSAT
  Dim    FreqFactorB_UW_VW_Prev    = 1 - 2*ACCURACY_FREQ_FACTOR   'previous FreqFactor_UW_VW
  Public FreqFactorB_WT_SONIC      = 1                            'freq correction factor for covariance of vertical wind with sonic temperature that are measured using CSAT
  Dim    FreqFactorB_WT_SONIC_Prev = 1 - 2*ACCURACY_FREQ_FACTOR   'previous FreqFactor_WT_SONIC
#EndIf

' ------ Numerical wTs transfer function Dijk (2002): alternatively kl and transfer function value where k is wavenumber and l is path length ------
' Hold following numerical values of transfer function of line averaging for wTs of CSAT measurements from Table 1 in Dijk (2012)
Dim tran_func_LA_data_Dijk(2,35) = { 0.00,0.01,0.10,0.20,0.50,1.00,1.20,1.40,1.60,1.80,2.00,2.20,2.40,2.60,2.80,3.00,4.00,5.00,6.00,7.00,8.00,9.00,10.0,14.0,20.0,30.0,40.0,50.0,60.0,70.0,80.0,90.0,100,300,10000, 1.00000,1.00000,0.99920,0.99760,0.99000,0.96700,0.95500,0.94170,0.92740,0.91220,0.89620,0.87970,0.86260,0.84520,0.82740,0.80960,0.72010,0.63530, 0.55880,0.49220,0.43550,0.38790,0.34810,0.24450,0.17000,0.11340,0.08503,0.06802,0.05668,0.04859,0.04251,0.03779,0.03401,1.89888e-2,1.6168e-4}
' The data points were extended to kl= 300 and 10000 according to the numerical derivative of transfer function with respect to kl from kl= 70 to 100.
' ----------------------------------------- End of numerical wTs transfer function values from Dijk (2002) ------------------------------------------
'*** END OF CORRECTION CONSTANTS AND VARIABLES ***

'**********************************************************************************
'*** BEGINNING OF CSAT SONIC HEADï¼šCONSTANTS, VARIABLES, AND WORKING DATA TABLES ***
'**********************************************************************************
Const PATH_LENGTH_CSAT = 0.1154701       'CSAT path length = 10 cm/sin(pi/3) (m)

Public sonic(5)
Alias  sonic(1) = Ts
Alias  sonic(2) = Ux
Alias  sonic(3) = Uy
Alias  sonic(4) = Uz
Alias  sonic(5) = diag_sonic
Units  Ts = deg C
Units  Ux      = m s-1
Units  Uy      = m s-1
Units  Uz      = m s-1
Units  diag_sonic = adimensional

Dim U_rslt
'Used to calculate Maximum resultant wind speed in an averaging period

#If CSAT3B_B Then
  Public sonicB(5)
  Alias  sonicB(1) = TBs
  Alias  sonicB(2) = UBx
  Alias  sonicB(3) = UBy
  Alias  sonicB(4) = UBz
  Alias  sonicB(5) = diag_sonicB
  Units  TBs = deg C
  Units  UBx      = m s-1
  Units  UBy      = m s-1
  Units  UBz      = m s-1
  Units  diag_sonicB = adimensional

  Dim UB_rslt
#EndIf

Dim   diag_bits_sonic(6) As Long           'Sonic warning flags
Alias diag_bits_sonic(1) = sonic_amp_l_f   'Amplitude low warning flag
Alias diag_bits_sonic(2) = sonic_amp_h_f   'Amplitude high warning flag
Alias diag_bits_sonic(3) = sonic_sig_lck_f 'Poor signal lock warning flag
Alias diag_bits_sonic(4) = sonic_del_T_f   'Delta temperature warning flag
Alias diag_bits_sonic(5) = sonic_aq_sig_f  'Sonic acquiring signals warning flag
Alias diag_bits_sonic(6) = sonic_cal_err_f 'Signature error in reading CSAT sonic head calibration data
Units diag_bits_sonic    = adimensional

#If CSAT3B_B

  Dim   diag_bits_sonicB(6) As Long            'Sonic warning flags
  Alias diag_bits_sonicB(1) = sonicB_amp_l_f   'Amplitude low warning flag
  Alias diag_bits_sonicB(2) = sonicB_amp_h_f   'Amplitude high warning flag
  Alias diag_bits_sonicB(3) = sonicB_sig_lck_f 'Poor signal lock warning flag
  Alias diag_bits_sonicB(4) = sonicB_del_T_f   'Delta temperature warning flag
  Alias diag_bits_sonicB(5) = sonicB_aq_sig_f  'Sonic acquiring signals warning flag
  Alias diag_bits_sonicB(6) = sonicB_cal_err_f 'Signature error in reading CSAT sonic head calibration data
  Units diag_bits_sonicB    = adimensional

#EndIf

Dim sonic_raw(5)
Dim sonicB_raw(5)                          'Hold the data from EC100 (CSAT, IRGA, temperature sensor, and barometer raw data before applying instrument scan lag)

Dim diag_sonic_tmp  As Long                'Working variable used to break out the CSAT sonic head diagnostic bits
Dim sonic_disable_f As Boolean             'TRUE when any CSAT diagnostic warning flag is on, CSAT has not sent data, or an SDM signature error is reported
Dim sonicB_disable_f As Boolean

Public diag_sonic_aggregate As Long         'Aggregated diagnosis code within an output interval, indicating the ocurrance of all flags.
Units diag_sonic_aggregate = adimensional

Dim mask            As Long                 'Masking the diagnosis code
Dim Ts_K ,TBs_K                             'Sonic temperature in K

#If CSAT3B_B Then
  Dim diag_sonicB_tmp As Long, diag_sonicB_aggregate As Long
  Units diag_sonicB_aggregate = adimensional
#EndIf

Dim cov_out_sonic(20)                      'CSAT sonic statistics
Alias cov_out_sonic(1)  = Ux_Avg
Alias cov_out_sonic(2)  = Ux_SIGMA
Alias cov_out_sonic(3)  = UxUy_Cov
Alias cov_out_sonic(4)  = UxUz_Cov
Alias cov_out_sonic(5)  = Uy_Avg
Alias cov_out_sonic(6)  = Uy_SIGMA
Alias cov_out_sonic(7)  = UyUz_Cov
Alias cov_out_sonic(8)  = Uz_Avg
Alias cov_out_sonic(9)  = Uz_SIGMA
Alias cov_out_sonic(10) = Ts_Avg          'Ts averaged over an averaging interval (AmeriFlux notation)
Alias cov_out_sonic(11) = Ts_SIGMA        'Ts standard deviation is stored here. Unlike standard deviation of momentum variable, it is not related to coordinate rotation (AmeriFlux notation)
Alias cov_out_sonic(12) = TsUx_Cov
Alias cov_out_sonic(13) = TsUy_Cov
Alias cov_out_sonic(14) = TsUz_Cov
Alias cov_out_sonic(15) = WS
Alias cov_out_sonic(16) = WS_RSLT         'Result wind speed (AmeriFlux notation)
Alias cov_out_sonic(17) = WD_SONIC        'wind direction of 0 to 360 degree in the CSAT coordinate system, equal to Gamma in coordination rotation.
Alias cov_out_sonic(18) = WD_SIGMA
Alias cov_out_sonic(19) = WS_MAX          'Maximum wind speed over an averaging interval (AmeriFlux notation)
Alias cov_out_sonic(20) = WD              'wind direction in compass convention (AmeriFlux notation)
Units Ux_Avg   = m s-1
Units Ux_SIGMA = m s-1
Units UxUy_Cov = m2 s-2
Units UxUz_Cov = m2 s-2
Units Uy_Avg   = m s-1
Units Uy_SIGMA = m s-1
Units UyUz_Cov = m2 s-2
Units Uz_Avg   = m s-1
Units Uz_SIGMA = m s-1
Units Ts_Avg   = deg C
Units Ts_SIGMA = deg C
Units TsUx_Cov = deg C m s-1
Units TsUy_Cov = deg C m s-1
Units TsUz_Cov = deg C m s-1
Units WS       = m s-1
Units WS_RSLT  = m s-1
Units WD_SONIC = decimal degrees
Units WD_SIGMA = decimal degrees
Units WS_MAX   = m s-1
Units WD       = decimal degrees

#If CSAT3B_B

  Dim cov_out_sonicB(20)                      'CSAT sonic statistics
  Alias cov_out_sonicB(1)  = UBx_Avg
  Alias cov_out_sonicB(2)  = UBx_SIGMA
  Alias cov_out_sonicB(3)  = UxUyB_Cov
  Alias cov_out_sonicB(4)  = UxUzB_Cov
  Alias cov_out_sonicB(5)  = UBy_Avg
  Alias cov_out_sonicB(6)  = UBy_SIGMA
  Alias cov_out_sonicB(7)  = UyUzB_Cov
  Alias cov_out_sonicB(8)  = UBz_Avg
  Alias cov_out_sonicB(9)  = UBz_SIGMA
  Alias cov_out_sonicB(10) = TBs_Avg          'Ts averaged over an averaging interval (AmeriFlux notation)
  Alias cov_out_sonicB(11) = TBs_SIGMA        'Ts standard deviation is stored here. Unlike standard deviation of momentum variable, it is not related to coordinate rotation (AmeriFlux notation)
  Alias cov_out_sonicB(12) = TsUxB_Cov
  Alias cov_out_sonicB(13) = TsUyB_Cov
  Alias cov_out_sonicB(14) = TsUzB_Cov
  Alias cov_out_sonicB(15) = WSB
  Alias cov_out_sonicB(16) = WSB_RSLT         'Result wind speed (AmeriFlux notation)
  Alias cov_out_sonicB(17) = WDB_SONIC        'wind direction of 0 to 360 degree in the CSAT coordinate system, equal to Gamma in coordination rotation.
  Alias cov_out_sonicB(18) = WDB_SIGMA
  Alias cov_out_sonicB(19) = WSB_MAX          'Maximum wind speed over an averaging interval (AmeriFlux notation)
  Alias cov_out_sonicB(20) = WDB              'wind direction in compass convention (AmeriFlux notation)
  Units UBx_Avg   = m s-1
  Units UBx_SIGMA = m s-1
  Units UxUyB_Cov = m2 s-2
  Units UxUzB_Cov = m2 s-2
  Units UBy_Avg   = m s-1
  Units UBy_SIGMA = m s-1
  Units UyUzB_Cov = m2 s-2
  Units UBz_Avg   = m s-1
  Units UBz_SIGMA = m s-1
  Units TBs_Avg   = deg C
  Units TBs_SIGMA = deg C
  Units TsUxB_Cov = deg C m s-1
  Units TsUyB_Cov = deg C m s-1
  Units TsUzB_Cov = deg C m s-1
  Units WSB       = m s-1
  Units WSB_RSLT  = m s-1
  Units WDB_SONIC = decimal degrees
  Units WDB_SIGMA = decimal degrees
  Units WSB_MAX   = m s-1
  Units WDB       = decimal degrees

#EndIf

' Variables after coordinate rotations as indicated by the last letter of "R".
' 3D wind components before coordinate roations are Ux, Uy, and Uz, and afterwards they are referred to as U, V, and W, respectively.
' Sonic temperatiure is denoted by Ts before coordinate roations and by T_SONIC afterwards
Dim USTAR_R                                'Friction velocity after coordinate rotations
Dim U
Dim U_SIGMA
Dim UV_Cov
Dim UW_Cov
Dim V
Dim V_SIGMA
Dim VW_Cov
Dim W
Dim W_SIGMA
Dim T_SONIC
Dim T_SONIC_SIGMA
Dim UT_SONIC_Cov
Dim VT_SONIC_Cov
Dim WT_SONIC_Cov

Units USTAR_R = m s-1
Units U       = m s-1
Units U_SIGMA = m s-1
Units UV_Cov  = m2 s-2
Units UW_Cov  = m2 s-2
Units V       = m s-1
Units V_SIGMA = m s-1
Units VW_Cov  = m2 s-2
Units W       = m s-1
Units W_SIGMA = m s-1
Units T_SONIC = deg C
Units T_SONIC_SIGMA = deg C
Units UT_SONIC_Cov  = deg C m s-1
Units VT_SONIC_Cov  = deg C m s-1
Units WT_SONIC_Cov  = deg C m s-1

Public TKE                           'specific turbulent kinetic energy
Units  TKE = m2 s-2                  '[kg (m/s)^2]/kg

' Variables after frequency corrections have an "_fc" appended.
' Note, however, there are exceptions such as H for sensible heat flux and TAU for momentum flux, both of which are after freq corrections.

Dim TAU                              'Drag force (stress) at surface (momentum flux) after coordinate rotations and freq corrections
Dim USTAR                            'Friction velocity after coordinate rotations and freq corrections
Dim WT_SONIC_Cov_fc
Dim UW_Cov_fc
Dim VW_Cov_fc

Units TAU             = kg m-1 s-2  'Equivalent to (kg/m^3)(m/s)^2
Units USTAR           = m s-1
Units WT_SONIC_Cov_fc = deg C m s-1
Units UW_Cov_fc       = m2 s-2
Units VW_Cov_fc       = m2 s-2

Public WT_SONIC_Cov_fc_SND         'Covariance of sonic temperature with vertical velocity after rotation, freq, and SND corrections
Public TSTAR                       'Scaling temperature
Public H                           'Sensible heat flux: Derived from covariance of sonic temperatur after rotation, freq, and SND corrections

Units  WT_SONIC_Cov_fc_SND = deg C m s-1
Units  TSTAR               = deg C
Units  H                   = W m-2

#If CSAT3B_B Then

  Dim USTARB_R                                'Friction velocity after coordinate rotations
  Dim UB
  Dim UB_SIGMA
  Dim UVB_Cov
  Dim UWB_Cov
  Dim VB
  Dim VB_SIGMA
  Dim VWB_Cov
  Dim WB
  Dim WB_SIGMA
  Dim TB_SONIC
  Dim TB_SONIC_SIGMA
  Dim UTB_SONIC_Cov
  Dim VTB_SONIC_Cov
  Dim WTB_SONIC_Cov


  Units USTARB_R = m s-1
  Units UB       = m s-1
  Units UB_SIGMA = m s-1
  Units UVB_Cov  = m2 s-2
  Units UWB_Cov  = m2 s-2
  Units VB       = m s-1
  Units VB_SIGMA = m s-1
  Units VWB_Cov  = m2 s-2
  Units WB       = m s-1
  Units WB_SIGMA = m s-1
  Units TB_SONIC = deg C
  Units TB_SONIC_SIGMA = deg C
  Units UTB_SONIC_Cov  = deg C m s-1
  Units VTB_SONIC_Cov  = deg C m s-1
  Units WTB_SONIC_Cov  = deg C m s-1

  Public TKEB                           'specific turbulent kinetic energy
  Units  TKEB = m2 s-2                  '[kg (m/s)^2]/kg

  ' Variables after frequency corrections have an "_fc" appended.
  ' Note, however, there are exceptions such as H for sensible heat flux and TAU for momentum flux, both of which are after freq corrections.

  Dim TAUB                              'Drag force (stress) at surface (momentum flux) after coordinate rotations and freq corrections
  Dim USTARB                            'Friction velocity after coordinate rotations and freq corrections
  Dim WTB_SONIC_Cov_fc
  Dim UWB_Cov_fc
  Dim VWB_Cov_fc

  Units TAUB             = kg m-1 s-2  'Equivalent to (kg/m^3)(m/s)^2
  Units USTARB           = m s-1
  Units WTB_SONIC_Cov_fc = deg C m s-1
  Units UWB_Cov_fc       = m2 s-2
  Units VWB_Cov_fc       = m2 s-2

  Public WTB_SONIC_Cov_fc_SND         'Covariance of sonic temperature with vertical velocity after rotation, freq, and SND corrections
  Public TSTARB                       'Scaling temperature
  Public HB                           'Sensible heat flux: Derived from covariance of sonic temperatur after rotation, freq, and SND corrections

  Units  WTB_SONIC_Cov_fc_SND = deg C m s-1
  Units  TSTARB               = deg C
  Units  HB                   = W m-2

#EndIf

'*** Data quality classification: Constant and variables
Const OUTPUT_INTERVAL_SST = 5      'Sub-interval to calculate the statistics for Steady State Test (SST) [minutes]

' Steady State Test (SST)
Public RN_UW_VW_cov                'Relative Non-Stationarity (RN) for momentum covariance (UW_Cov and VW_Cov)
Public RN_UW_cov                   'Relative non-Stationarity for UW_Cov. It is also used for the sum of UxUz_Cov_SST below from 5-min sub-intervals.
Public RN_VW_cov                   'Relative non-Stationarity for VW_Cov. It is also used for the sum of UyUz_Cov_SST below from 5-min sub-intervals.
Public RN_WT_SONIC_cov             'Relative non-Stationarity for wTs_cov_R. It is also used for the sum of TsUz_Cov_SST below from 5-min sub-intervals.
Public nmbr_interval_qc_csat       'Number of sub-intervals = (OUTPUT_INTV)/(OUTPUT_INTERVAL_SST)


Dim cov_out_sonic_SST(17)          'CSAT sonic head statistics for Steady State Test (SST)
Alias cov_out_sonic_SST(1)  = Ux_Avg_SST
Alias cov_out_sonic_SST(2)  = Ux_Var_SST
Alias cov_out_sonic_SST(3)  = UxUy_Cov_SST
Alias cov_out_sonic_SST(4)  = UxUz_Cov_SST
Alias cov_out_sonic_SST(5)  = Uy_Avg_SST
Alias cov_out_sonic_SST(6)  = Uy_Var_SST
Alias cov_out_sonic_SST(7)  = UyUz_Cov_SST
Alias cov_out_sonic_SST(8)  = Uz_Avg_SST
Alias cov_out_sonic_SST(9)  = Uz_Var_SST
Alias cov_out_sonic_SST(10) = T_SONIC_Var_SST
Alias cov_out_sonic_SST(11) = TsUx_Cov_SST
Alias cov_out_sonic_SST(12) = TsUy_Cov_SST
Alias cov_out_sonic_SST(13) = TsUz_Cov_SST
Alias cov_out_sonic_SST(14) = WS_SST
Alias cov_out_sonic_SST(15) = WS_RSLT_SST
Alias cov_out_sonic_SST(16) = WD_SONIC_SST       'Wind direction in CSAT coordinate system (0 to 360 degree)
Alias cov_out_sonic_SST(17) = WD_SIGMA_SST

' Variables for steady State Test after coordinate rotations
Dim U_SST
Dim U_Var_SST
Dim UV_Cov_SST
Dim UW_Cov_SST
Dim V_SST
Dim V_Var_SST
Dim VW_Cov_SST
Dim W_SST
Dim W_Var_SST
Dim UT_SONIC_Cov_SST
Dim VT_SONIC_Cov_SST
Dim WT_SONIC_Cov_SST

' Data quality grading
Public TAU_SSITC_TEST As Long        'Results of the Steady State and Integral Turbulence Characteristics for TAU according to Foken et al (2004)
Public H_SSITC_TEST   As Long        'Results of the Steady State and Integral Turbulence Characteristics for H according to Foken et al (2004)
Units  TAU_SSITC_TEST = adimensional
Units  H_SSITC_TEST   = adimensional

Public TAU_QC As Long               'Overall grade of data QC for momentum flux (i.e. for variable: TAU) [1 (highest) to 9 (lowest)] according to Foken et al (2012)
Public H_QC   As Long               'Overall grade of data QC for sensible heat flux (i.e. for variable: H) [1 (highest) to 9 (lowest)] according to Foken et al (2012)
Units TAU_QC = grade
Units H_QC   = grade

#If CSAT3B_B Then

  Public RN_UW_VWB_cov                'Relative Non-Stationarity (RN) for momentum covariance (UW_Cov and VW_Cov)
  Public RN_UWB_cov                   'Relative non-Stationarity for UW_Cov. It is also used for the sum of UxUz_Cov_SST below from 5-min sub-intervals.
  Public RN_VWB_cov                   'Relative non-Stationarity for VW_Cov. It is also used for the sum of UyUz_Cov_SST below from 5-min sub-intervals.
  Public RN_WTB_SONIC_cov             'Relative non-Stationarity for wTs_cov_R. It is also used for the sum of TsUz_Cov_SST below from 5-min sub-intervals.
  Public nmbr_interval_qc_csatB       'Number of sub-intervals = (OUTPUT_INTV)/(OUTPUT_INTERVAL_SST)

  Dim cov_out_sonicB_SST(17)          'CSAT sonic head statistics for Steady State Test (SST)
  Alias cov_out_sonicB_SST(1)  = UBx_Avg_SST
  Alias cov_out_sonicB_SST(2)  = UBx_Var_SST
  Alias cov_out_sonicB_SST(3)  = UxUyB_Cov_SST
  Alias cov_out_sonicB_SST(4)  = UxUzB_Cov_SST
  Alias cov_out_sonicB_SST(5)  = UBy_Avg_SST
  Alias cov_out_sonicB_SST(6)  = UBy_Var_SST
  Alias cov_out_sonicB_SST(7)  = UyUzB_Cov_SST
  Alias cov_out_sonicB_SST(8)  = UBz_Avg_SST
  Alias cov_out_sonicB_SST(9)  = UBz_Var_SST
  Alias cov_out_sonicB_SST(10) = TB_SONIC_Var_SST
  Alias cov_out_sonicB_SST(11) = TsUxB_Cov_SST
  Alias cov_out_sonicB_SST(12) = TsUyB_Cov_SST
  Alias cov_out_sonicB_SST(13) = TsUzB_Cov_SST
  Alias cov_out_sonicB_SST(14) = WSB_SST
  Alias cov_out_sonicB_SST(15) = WSB_RSLT_SST
  Alias cov_out_sonicB_SST(16) = WDB_SONIC_SST       'Wind direction in CSAT coordinate system (0 to 360 degree)
  Alias cov_out_sonicB_SST(17) = WDB_SIGMA_SST

  ' Variables for steady State Test after coordinate rotations
  Dim UB_SST
  Dim UB_Var_SST
  Dim UVB_Cov_SST
  Dim UWB_Cov_SST
  Dim VB_SST
  Dim VB_Var_SST
  Dim VWB_Cov_SST
  Dim WB_SST
  Dim WB_Var_SST
  Dim UTB_SONIC_Cov_SST
  Dim VTB_SONIC_Cov_SST
  Dim WTB_SONIC_Cov_SST

  ' Data quality grading
  Public TAU_SSITC_TESTB As Long        'Results of the Steady State and Integral Turbulence Characteristics for TAU according to Foken et al (2004)
  Public H_SSITC_TESTB   As Long        'Results of the Steady State and Integral Turbulence Characteristics for H according to Foken et al (2004)
  Units  TAU_SSITC_TESTB = adimensional
  Units  H_SSITC_TESTB   = adimensional

  Public TAU_QCB As Long               'Overall grade of data QC for momentum flux (i.e. for variable: TAU) [1 (highest) to 9 (lowest)] according to Foken et al (2012)
  Public H_QCB   As Long                'Overall grade of data QC for sensible heat flux (i.e. for variable: H) [1 (highest) to 9 (lowest)] according to Foken et al (2012)
  Units TAU_QCB = grade
  Units H_QCB   = grade

#EndIf

'*** Footprint characteristics: Constant and variables ***
' Footprint characteristics
Const  NMBR_INT_INTERV_SEGMENT = 20  'Base number of numerical integration intervals for footprint characteristics in each integration segment

'Raw data table
DataTable (delay_3d, TRUE, 50)
  TableHide
  Sample (4, sonic_raw(1), IEEE4)             'Sonic data: Ux, Uy, Uz, and Ts
  Sample (1, sonic_raw(5), Long)              'Sonic data: diag_sonic
EndTable

DataTable (delay_3dB, TRUE, 50)
  TableHide
  Sample (4, sonicB_raw(1), IEEE4)             'Sonic data: Ux, Uy, Uz, and Ts
  Sample (1, sonicB_raw(5), Long)              'Sonic data: diag_sonic
EndTable

'5-minute covariance of CSAT data for steady state tests
DataTable (comp_cov_3d_5min, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL_SST, Min, 0)

  'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from CSAT data.
  Average    (1, Ux, IEEE4, sonic_disable_f)      'Using sonic(2)
  Covariance (3, Ux, IEEE4, sonic_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

  'Compute Uy mean and covariance of Uy with, Uy, Uz from CSAT data.
  Average    (1, Uy, IEEE4, sonic_disable_f)      'Using sonic(3)
  Covariance (2, Uy, IEEE4, sonic_disable_f, 2)   'Using sonic(3) and sonic(4)

  'Compute Uz mean and covariance of Uz with Uz from CSAT data.
  Average    (1,Uz, IEEE4, sonic_disable_f)       'Using sonic(4)
  Covariance (1,Uz, IEEE4, sonic_disable_f, 1)    'Using sonic(4)

  'Compute covariance of Ts with Ts, Ux, Uy, and Uz from CSAT data.
  Covariance (4, Ts, IEEE4, sonic_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

  WindVector (1, Uy, Ux, IEEE4, sonic_disable_f, 0, 1, 2)
EndTable

' 30-minute covariance of CSAT data
DataTable (comp_cov_3d, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from CSAT data.
  Average    (1, Ux, IEEE4,sonic_disable_f)      'Using sonic(2)
  Covariance (3, Ux, IEEE4,sonic_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

  'Compute Uy mean and covariance of Uy with, Uy, Uz from CSAT data.
  Average    (1, Uy, IEEE4,sonic_disable_f)      'Using sonic(3)
  Covariance (2, Uy, IEEE4,sonic_disable_f, 2)   'Using sonic(3) and sonic(4)

  'Compute Uz mean and covariance of Uz with Uz (i.e. variance) from CSAT data.
  Average    (1, Uz, IEEE4,sonic_disable_f)      'Using sonic(4)
  Covariance (1, Uz, IEEE4,sonic_disable_f, 1)   'Using sonic(4)

  'Compute Ts mean and covariance of Ts with Ts, Ux, Uy, and Uz from CSAT data.
  Average    (1, Ts, IEEE4,sonic_disable_f)      'Using sonic(1)
  Covariance (4, Ts, IEEE4,sonic_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

  WindVector (1, Uy, Ux, IEEE4, sonic_disable_f, 0, 1, 2)

  'Compute the maximum of wind speed in an averaging interval
  Maximum (1, U_rslt, IEEE4, sonic_disable_f, False)

EndTable

#If CSAT3B_B Then

  '5-minute covariance of CSAT data for steady state tests
  DataTable (comp_covB_3d_5min, TRUE, 1)
    TableHide
    DataInterval (0, OUTPUT_INTERVAL_SST, Min, 0)

    'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from CSAT data.
    Average    (1, UBx, IEEE4, sonicB_disable_f)   'Using sonic(2), sonic(3), and sonic(4)

    'Compute Uy mean and covariance of Uy with, Uy, Uz from CSAT data.
    Average    (1, UBy, IEEE4, sonicB_disable_f)      'Using sonic(3)
    Covariance (2, UBy, IEEE4, sonicB_disable_f, 2)   'Using sonic(3) and sonic(4)

    'Compute Uz mean and covariance of Uz with Uz from CSAT data.
    Average    (1,UBz, IEEE4, sonicB_disable_f)       'Using sonic(4)
    Covariance (1,UBz, IEEE4, sonicB_disable_f, 1)    'Using sonic(4)

    'Compute covariance of Ts with Ts, Ux, Uy, and Uz from CSAT data.
    Covariance (4, TBs, IEEE4, sonicB_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

    WindVector (1, UBy, UBx, IEEE4, sonicB_disable_f, 0, 1, 2)
  EndTable

  ' 30-minute covariance of CSAT data
  DataTable (comp_covB_3d, TRUE, 1)
    TableHide
    DataInterval (0, OUTPUT_INTV, Min, 0)

    'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from CSAT data.
    Average    (1, UBx, IEEE4,sonicB_disable_f)      'Using sonic(2)
    Covariance (3, UBx, IEEE4,sonicB_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

    'Compute Uy mean and covariance of Uy with, Uy, Uz from CSAT data.
    Average    (1, UBy, IEEE4,sonicB_disable_f)      'Using sonic(3)
    Covariance (2, UBy, IEEE4,sonicB_disable_f, 2)   'Using sonic(3) and sonic(4)

    'Compute Uz mean and covariance of Uz with Uz (i.e. variance) from CSAT data.
    Average    (1, UBz, IEEE4,sonicB_disable_f)      'Using sonic(4)
    Covariance (1, UBz, IEEE4,sonicB_disable_f, 1)   'Using sonic(4)

    'Compute Ts mean and covariance of Ts with Ts, Ux, Uy, and Uz from CSAT data.
    Average    (1, TBs, IEEE4,sonicB_disable_f)      'Using sonic(1)
    Covariance (4, TBs, IEEE4,sonicB_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

    WindVector (1, UBy, UBx, IEEE4, sonicB_disable_f, 0, 1, 2)

    'Compute the maximum of wind speed in an averaging interval
    Maximum (1, UB_rslt, IEEE4, sonicB_disable_f, False)

  EndTable

#EndIf

'*** END OF CSAT SONIC HEADï¼šCONSTANTS, VARIABLES, AND WORKING DATA TABLES ***

'************************************************************************************************
'*** BEGINNING OF TEMPERATURE AND HUMIDITY PROBE CONSTANTS, VARIABLES, AND WORKING DATA TABLE ***
'************************************************************************************************
Public tmpr_rh(14)
Alias tmpr_rh(1) = T_probe                    'Temperature/humidity probe: Temperature
Alias tmpr_rh(2) = RH_probe                   'Temperature/humidity probe: Relative humidity
Alias tmpr_rh(3) = T_DP_Probe                 'Temperature/humidity probe: Dew point temperature
Alias tmpr_rh(4) = e_probe                    'Temperature/humidity probe: vapor pressure
Alias tmpr_rh(5) = e_sat_probe                'Temperature/humidity probe: Saturate vapor pressure
Alias tmpr_rh(6) = H2O_probe                  'Temperature/humidity probe: Water vapor density
Alias tmpr_rh(7) = rho_d_probe                'dry Air density
Alias tmpr_rh(8) = T107_probe                 'Temperature
Alias tmpr_rh(9) = amb_press                  'air press in kPa
Alias tmpr_rh(10) = HSact                     'snow height in cm
Alias tmpr_rh(11) = rho_a_probe               'Air density
Alias tmpr_rh(12) = Treal
Alias tmpr_rh(13) = WaterPress23s             'Waterpressure, Bar
Alias tmpr_rh(14) = WaterFlow                 'Waterflow in l/min



Units T_probe     = deg C
Units RH_probe    = %
Units T_DP_Probe  = deg C
Units e_probe     = kPa
Units e_sat_probe = kPa
Units H2O_probe   = g/m^3
Units rho_d_probe = g/m^3
Units T107_probe     = deg C
Units amb_press     = kPa
Units HSact     = cm
Units rho_a_probe = g/m^3
Units Treal = degr C
Units WaterPress23s = Bar
Units WaterFlow  = l/min

Public HSmeas                   ' SR50a raw measurement

Public Tice(16), Tice_OFST(16)
Units Tice() = dec C
Units Tice_OFST() = deg C

Dim Enhance_factor1_probe                     'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim Enhance_factor2_probe                     'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim x_tmp_probe                               'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim Td_gp_probe                               'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature

Dim stats_out_tmpr_rh(14)                      'Temperature/humidity probe: statistics
Alias stats_out_tmpr_rh(1) = T_probe_Avg      'Average temperature measured using temperature/humidity probe
Alias stats_out_tmpr_rh(2) = RH_probe_Avg     'Average temperature measured using temperature/humidity probe
Alias stats_out_tmpr_rh(3) = T_DP_probe_Avg   'Average dew point temperature measured using temperature/humidity probe
Alias stats_out_tmpr_rh(4) = e_probe_Avg      'Average vapor pressure measured using temperature/humidity probe
Alias stats_out_tmpr_rh(5) = e_sat_probe_Avg  'Average saturation vapor pressure measured using temperature/humidity probe
Alias stats_out_tmpr_rh(6) = H2O_probe_Avg    'Average vapor density measured using temperature/humidity probe
Alias stats_out_tmpr_rh(7) = rho_d_probe_Avg  'Average dry air density measured using temperature/humidity probe
Alias stats_out_tmpr_rh(8) = T107_probe_Avg   'T107
Alias stats_out_tmpr_rh(9) = amb_press_Avg    'amb pressure
Alias stats_out_tmpr_rh(10) = HSact_Avg       'snow height
Alias stats_out_tmpr_rh(11) = rho_a_probe_Avg 'Average moist air density measured using Temperature/humidity probe
Alias stats_out_tmpr_rh(12) = Treal_Avg
Alias stats_out_tmpr_rh(13) = WaterPress23s_Avg             'Waterpressure, Bar
Alias stats_out_tmpr_rh(14) = WaterFlow_Avg                 'Waterflow in l/min

Units T_probe_Avg     = deg C
Units RH_probe_Avg    = %
Units T_DP_probe_Avg  = deg C
Units e_probe_Avg     = kPa
Units e_sat_probe_Avg = kPa
Units H2O_probe_Avg   = g/m^3
Units rho_d_probe_Avg = g/m^3
Units T107_probe_Avg     = deg C
Units amb_press_Avg     = kPa
Units HSact_Avg     = cm
Units rho_a_probe_Avg = g/m^3
Units Treal_Avg = degr C
Units WaterPress23s_Avg  = Bar                             'Waterpressure, Bar
Units WaterFlow_Avg  = l/min                               'Waterflow in l/min

DataTable (stats_tmpr_rh,TRUE,1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)

  Average (14, T_probe, IEEE4, slowsequence_disable_f)

EndTable
'*** END OF TEMPERATURE AND HUMIDITY PROBE CONSTANTS, VARIABLES, AND WORKING DATA TABLE ***


'********************************************************************
'*** BEGINNING OF NET RADIOMETER: CONSTANTS, VARIABLES, AND TABLE ***
'********************************************************************
Dim NETRAD_raw                                         'Net radiation: Measured time series data

Public nr_mean(7)                     'Radiation components measured from one net radiometer or one 4-way net radiometer.
Alias nr_mean(1) = NETRAD                              'Net radiation: mean over an averaging interval
Units NETRAD     = W m-2

Alias nr_mean(2) = ALB                                 'Albedo in AmerFlux format
Alias nr_mean(3) = SW_IN                   'Incoming (downwelling) short wave radiation (This variable should be SW_IN in the final storage
Alias nr_mean(4) = SW_OUT                              'Outgoing (upwelling) short wave radiation
Alias nr_mean(5) = LW_IN                               'Incoming (downwelling) long wave radiation
Alias nr_mean(6) = LW_OUT                              'Outgoing (upwelling) long wave radiation
Alias nr_mean(7) = T_nr_Avg                            'Sensor body temperature.
Units ALB             = %
Units SW_IN           = W m-2
Units SW_OUT          = W m-2
Units LW_IN           = W m-2
Units LW_OUT          = W m-2
Units T_nr_Avg        = Klvin

'*** Beginning of 4-way net radiometer constants and variables ****
Public nr(8)      'Radiation components measured from a 4-way net radiometer.
Alias nr(1) = albedo
Alias nr(2) = R_SW_in              'Incoming (downwelling) short wave radiation
Alias nr(3) = R_SW_out             'Outgoing (upwelling) short wave radiation
Alias nr(4) = R_LW_in              'Incoming (downwelling) long wave radiation
Alias nr(5) = R_LW_out             'Outgoing (upwelling) long wave radiation
Alias nr(6) = T_nr                 'Sensor body temperature
Alias nr(7) = R_LW_in_meas         'Measured signal of incoming (downwelling) long wave radiation
Alias nr(8) = R_LW_out_meas        'Measured signal of outgoing (upwelling) long wave radiation
Units albedo        = %
Units R_SW_in       = W m-2
Units R_SW_out      = W m-2
Units R_LW_in       = W m-2
Units R_LW_out      = W m-2
Units T_nr          = Klvin
Units R_LW_in_meas  = W m-2
Units R_LW_out_meas = W m-2

'YSI 44031 Steinhart-Hart coefficients fit through -40 degrees C (239800 ohms), 20 degrees C (12260 ohms), and 80 degrees C (1458 ohms).
Const A_SHH = 1.0295e-3           'Steinhart-Hart A coefficient (from Kipp & Zonen through email April 16 2015).
Const B_SHH = 2.3910e-4           'Steinhart-Hart B coefficient (from Kipp & Zonen through email April 16 2015).
Const C_SHH = 1.5680e-7           'Steinhart-Hart C coefficient (from Kipp & Zonen through email April 16 2015).
Dim X_cnr4
Dim ln_R


'*** End of 4-way net radiometer constants and variables ****

DataTable (stats_net_radiation, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTV, Min, 0)
  Average (1, NETRAD_raw, IEEE4, slowsequence_disable_f)
  Average (6, albedo,   IEEE4, slowsequence_disable_f)
EndTable
'*** END OF NET RADIOMETER: CONSTANTS, VARIABLES, AND TABLE ***


'*************************************************************************
'*** BEGINNING OF ADDITIONAL VARIABLE FOR SHORT WAVE RADIATION SENSORS ***
'*************************************************************************
'Public SW_IN
'Units  SW_IN = W m-2
'*** END OF ADDITIONAL VARIABLE FOR SHORT WAVE RADIATION SENSORS ***

'******************************
'*** BEGINNING DISPLAY MENU ***
'******************************
DisplayMenu ("System Control", TRUE)
  SubMenu ("Site Var Settings")
    MenuItem ("Meas Height",   height_measurement)
    MenuItem ("Meas HeightB",   height_measurementB)
    MenuItem ("Surface Type", surface_type)
    MenuPick (CROP, GRASS, FOREST, SHRUB, BARELAND, WATER, ICE)
    MenuItem ("Canopy Height", height_canopy)
    MenuItem ("d, 0 = auto",   displacement_user)                        'if 0, zero displacement is automatically calculated in the program
    MenuItem ("z0,0 = auto",   roughness_user)                           'if 0, roughness length is automatically calculated in the program

    MenuItem ("Sonic Azmth", sonic_azimuth)
    MenuItem ("Sonic AzmthB", sonic_azimuthB)
    MenuItem ("Latitude",    latitude)
    MenuItem ("Hemisph_NS",  hemisphere_NS)
    MenuPick (NORTH, SOUTH)
    MenuItem ("Longitude",   longitude)
    MenuItem ("Hemisph_EW",  hemisphere_EW)
    MenuPick (EAST, WEST)
    MenuItem ("Altitude",    altitude)

  EndSubMenu

EndMenu
'*** END DISPLAY MENU ***

'*****************************************'
'*** FLUX TABLE IN CSI VARIABLE FORMAT ***'
'*****************************************'
DataTable (Flux_CSFormat, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTV, Min, 0)
  TableFile ("CRD:"&"_Flux_CSFormat_", 64, -1, 0, DAY_FLUX_CRD, day, 0, LastFileName_flux_CSFormat)

  Sample (1, H,       IEEE4)    'Sensible heat flux (derived from sonic heat flux with SND correction after coordinate rotations and freq corrections)
  Sample (1, H_QC,    Long)    'Overall grade of data quality for sensible heat flux (i.e. for variable: H) according to Foken et al. (2012)
  Totalize (1, n, Long, (sonic_disable_f)  'Totalize the number of samples for sensible heat flux
  FieldNames ("H_samples")

  'Sample (1, NETRAD, IEEE4)

  Sample (1, TAU,           IEEE4)       'Momentum flux after coordinate rotations and freq corrections,
  Sample (1, TAU_QC,        Long)        'Overall grade of data quality for momentum flux (i.e. for variable: TAU) according to Foken et al. (2012)

  '*** Turbulence characteristic variables
  Sample (1, USTAR,         IEEE4)      'Friction velocity after coordinate rotations and freq corrections
  Sample (1, TSTAR,         IEEE4)      'Scaling temperature after coordinate rotations and freq corrections
  Sample (1, TKE,           IEEE4)      'Specific turbulence kinetic energy after coordinate rotations

  '*** Temperature and humidity probe data
  Sample (1, amb_press_Avg,             IEEE4)  'Atmospheric pressure
  Sample (1, T107_probe_Avg,       IEEE4)  'Air temperature T107 temperature probe
  Sample (3, T_probe_Avg,       IEEE4)  'T, RH and T_DP
  Sample (3, e_probe_Avg,   IEEE4)      'Measured from temperature and humidity probe: e_probe_Avg, e_sat_probe_Avg, H2O_probe_Avg
  FieldNames("e_probe,e_sat_probe,H2O_probe")

  '*** CSAT sonic head data
  Sample (2, Ux_Avg,        IEEE4)      'Ux_avg and Ux_SIGMA before coordinate rotations
  FieldNames ("Ux,Ux_SIGMA")
  Sample (2, Uy_Avg,        IEEE4)      'Uy_avg and Uy_SIGMA before coordinate rotations
  FieldNames ("Uy,Uy_SIGMA")
  Sample (2, Uz_Avg,        IEEE4)      'Uz_avg and Uz_SIGMA before coordinate rotations
  FieldNames ("Uz,Uz_SIGMA")
  Sample (1, T_SONIC,       IEEE4)      'Average sonic temperature
  Sample (1, T_SONIC_SIGMA, IEEE4)      'Standard deviation of sonic temperature.
  Sample (1, sonic_azimuth, IEEE4)      'Sonic_azimuth, (see Section 3.2.1 CSAT3B Azimuth in the OPEC manual).
  Sample (4, WS,            IEEE4)      'WS, WS_RSLT, WD_SONIC, and WD_SIGMA.
  Sample (1, WD,            IEEE4)      'WD.
  Sample (1, WS_MAX,        IEEE4)      'WS_MAX.

  '***MET_WIND
  Sample (1, ZL,             IEEE4)  'Atmospheric boundary-layer stability.
  Sample (1, TAU_SSITC_TEST, Long)   'Results of the Steady State and Integral Turbulence Characteristics for TAU according to Foken et al (2004)
  Sample (1, MO_LENGTH,      IEEE4)  'Monin-Obukhov length
  Sample (1, U,              IEEE4)  'Average wind speed in stream-wise direction after coordinate rotation
  Sample (1, U_SIGMA,        IEEE4)  'Standard deviation of wind speed in stream-wise wind direction after coordinate rotation
  Sample (1, V,              IEEE4)  'Average wind speed in cross-stream direction after coordinate rotation
  Sample (1, V_SIGMA,        IEEE4)  'Standard deviation of wind speed in cross-stream direction after coordinate rotation
  Sample (1, W,              IEEE4)  'Average vertical wind speed after coordinate rotation
  Sample (1, W_SIGMA,        IEEE4)  'Standard deviation of vertical wind after coordinate rotation

  '*** Radiometer data
  'Albedo
  Sample  (7, NETRAD, IEEE4)                      'For use of the same variable in AmeriFlux format for SW incoming radiation from different sensors
  'Average (2, R_LW_in_meas,   IEEE4, slowsequence_disable_f)              'Average raw long-wave incoming radiation (R_LW_in_meas) and outgoing radiation (R_LW_out_meas) w/o temperature correction
  'FieldNames ("R_LW_in_meas,R_LW_out_meas")

  Average  (5, sun_azimuth, IEEE4, slowsequence_disable_f)
  FieldNames("sun_azimuth,sun_elevation,hour_angle,sun_declination,air_mass_coeff")
  Totalize (1, daytime_frac_scan_intv, IEEE4, slowsequence_disable_f)
  FieldNames("daytime")

  'other data
  Sample (1,HSact_Avg,FP2)
  FieldNames("SnowHeight")
  Sample (1,WaterPress23s,FP2)
  FieldNames("Waterpressure")
  Sample (1,WaterFlow,FP2)
  FieldNames("WaterFlow")

  #If SENSOR_Icetemp_JB1
    Average (8,Tice(1),FP2,false)
  #EndIf
  #If SENSOR_Icetemp_JB2 Then
    Average (8,Tice(9),FP2,false)
  #EndIf

EndTable
'*** End of Flux_CSFormat Table ****

#If CSAT3B_B Then
  '*****************************************'
  '*** FLUXB TABLE IN CSI VARIABLE FORMAT ***'
  '*****************************************'
  DataTable (FluxB_CSFormat, TRUE, FLUX_SIZE_CPU)
    DataInterval (0, OUTPUT_INTV, Min, 0)
    TableFile ("CRD:"&"_FluxB_CSFormat_", 64, -1, 0, DAY_FLUX_CRD, day, 0, LastFileName_fluxB_CSFormat)

    Sample (1, HB,       IEEE4)    'Sensible heat flux (derived from sonic heat flux with SND correction after coordinate rotations and freq corrections)
    Sample (1, H_QCB,    Long)    'Overall grade of data quality for sensible heat flux (i.e. for variable: H) according to Foken et al. (2012)
    Totalize (1, nB, Long, (sonic_disable_f)  'Totalize the number of samples for sensible heat flux
    FieldNames ("HB_samples")

    'Sample (1, NETRAD, IEEE4)

    Sample (1, TAUB,           IEEE4)       'Momentum flux after coordinate rotations and freq corrections,
    Sample (1, TAU_QCB,        Long)        'Overall grade of data quality for momentum flux (i.e. for variable: TAU) according to Foken et al. (2012)

    '*** Turbulence characteristic variables
    Sample (1, USTARB,         IEEE4)      'Friction velocity after coordinate rotations and freq corrections
    Sample (1, TSTARB,         IEEE4)      'Scaling temperature after coordinate rotations and freq corrections
    Sample (1, TKEB,           IEEE4)      'Specific turbulence kinetic energy after coordinate rotations

    '*** Temperature and humidity probe data
    Sample (1, amb_press_Avg,             IEEE4)  'Atmospheric pressure
    Sample (1, T107_probe_Avg,       IEEE4)  'Air temperature T107 temperature probe
    Sample (3, T_probe_Avg,       IEEE4)  'T, RH and T_DP
    Sample (3, e_probe_Avg,   IEEE4)      'Measured from temperature and humidity probe: e_probe_Avg, e_sat_probe_Avg, H2O_probe_Avg
    FieldNames("e_probe,e_sat_probe,H2O_probe")

    '*** CSAT sonic head data
    Sample (2, UBx_Avg,        IEEE4)      'Ux_avg and Ux_SIGMA before coordinate rotations
    FieldNames ("UBx,UBx_SIGMA")
    Sample (2, UBy_Avg,        IEEE4)      'Uy_avg and Uy_SIGMA before coordinate rotations
    FieldNames ("UBy,UBy_SIGMA")
    Sample (2, UBz_Avg,        IEEE4)      'Uz_avg and Uz_SIGMA before coordinate rotations
    FieldNames ("UBz,UBz_SIGMA")
    Sample (1, TB_SONIC,       IEEE4)      'Average sonic temperature
    Sample (1, TB_SONIC_SIGMA, IEEE4)      'Standard deviation of sonic temperature.
    Sample (1, sonic_azimuthB, IEEE4)      'Sonic_azimuth, (see Section 3.2.1 CSAT3B Azimuth in the OPEC manual).
    Sample (4, WSB,            IEEE4)      'WS, WS_RSLT, WD_SONIC, and WD_SIGMA.
    Sample (1, WDB,            IEEE4)      'WD.
    Sample (1, WSB_MAX,        IEEE4)      'WS_MAX.

    '***MET_WIND
    Sample (1, ZLB,             IEEE4)  'Atmospheric boundary-layer stability.
    Sample (1, TAU_SSITC_TESTB, Long)   'Results of the Steady State and Integral Turbulence Characteristics for TAU according to Foken et al (2004)
    Sample (1, MO_LENGTHB,      IEEE4)  'Monin-Obukhov length
    Sample (1, UB,              IEEE4)  'Average wind speed in stream-wise direction after coordinate rotation
    Sample (1, UB_SIGMA,        IEEE4)  'Standard deviation of wind speed in stream-wise wind direction after coordinate rotation
    Sample (1, VB,              IEEE4)  'Average wind speed in cross-stream direction after coordinate rotation
    Sample (1, VB_SIGMA,        IEEE4)  'Standard deviation of wind speed in cross-stream direction after coordinate rotation
    Sample (1, WB,              IEEE4)  'Average vertical wind speed after coordinate rotation
    Sample (1, WB_SIGMA,        IEEE4)  'Standard deviation of vertical wind after coordinate rotation

    '*** Radiometer data

    Sample  (7, NETRAD, IEEE4)
    'Average (2, R_LW_in_meas,   IEEE4, slowsequence_disable_f)              'Average raw long-wave incoming radiation (R_LW_in_meas) and outgoing radiation (R_LW_out_meas) w/o temperature correction
    'FieldNames ("R_LW_in_meas,R_LW_out_meas")

    Average  (5, sun_azimuth, IEEE4, slowsequence_disable_f)
    FieldNames("sun_azimuth,sun_elevation,hour_angle,sun_declination,air_mass_coeff")
    Totalize (1, daytime_frac_scan_intv, IEEE4, slowsequence_disable_f)
    FieldNames("daytime")

    'other data
    Sample (1,HSact_Avg,FP2)
    FieldNames("SnowHeight")
    Sample (1,WaterPress23s,FP2)
    FieldNames("Waterpressure")
    Sample (1,WaterFlow,FP2)
    FieldNames("WaterFlow")

  EndTable
  '*** End of FluxB_CSFormat Table ****
#EndIf

'*** BEGINNING OF FLUX_NOTES TABLE *****
DataTable (Flux_Notes, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTV, Min, 0)
  TableFile ("CRD:"&"_Flux_Notes_", 64, -1, 0,DAY_FLUX_CRD, day, 0, 0)

  '*** Beginning of CSAT sonic head data ***
  '*** Before coordinate rotation
  Sample (2, UxUy_Cov,  IEEE4)    'UxUy_Cov and UxUz_Cov.
  Sample (1, UyUz_Cov,  IEEE4)
  Sample (3, TsUx_Cov,  IEEE4)    'TsUx_Cov, TsUy_Cov, and TsUz_Cov

  '** After coordinate rotations
  '   Ux is represented by U, Uy by V, Uz by W, and Ts by T_SONIC, if this rule is not applicable, _R is added for the indication of coordinate-rotated variable.
  Sample (1, USTAR_R,  IEEE4)    'Friction velocity after coordinate rotations.
  Sample (1, U,        IEEE4)
  Sample (1, U_SIGMA,  IEEE4)
  Sample (1, V,        IEEE4)
  Sample (1, V_SIGMA,  IEEE4)
  Sample (1, W,        IEEE4)
  Sample (1, W_SIGMA,  IEEE4)
  Sample (1, UV_Cov,   IEEE4)
  Sample (1, UW_Cov,   IEEE4)
  Sample (1, VW_Cov,   IEEE4)
  Sample (1, UT_SONIC_Cov, IEEE4)
  Sample (1, VT_SONIC_Cov, IEEE4)
  Sample (1, WT_SONIC_Cov, IEEE4)

  '*** _fc indicates after frequency corrections
  Sample (1, UW_Cov_fc,       IEEE4)
  Sample (1, VW_Cov_fc,       IEEE4)
  Sample (1, WT_SONIC_Cov_fc, IEEE4)

  '** After coordinate rotations, freq corrections, and SND correction as indicated by WT_SONIC, fc, and SND.
  Sample (1, WT_SONIC_Cov_fc_SND,  IEEE4)

  '** Summary of diagnosis flags of CSAT
  Totalize (1, n, Long, sonic_disable_f)  'Totalize the number of sonic samples without diagnostic flags
  FieldNames ("sonic_samples")
  Sample (1, diag_sonic_aggregate, Long)
  Totalize (1, n, Long, diag_sonic <> -1)
  FieldNames ("no_sonic_head_Tot")
  Totalize (1, n, Long, diag_sonic <> NAN)
  FieldNames ("no_new_sonic_data_Tot")
  Totalize (1, n, Long, sonic_amp_l_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_amp_l_f_Tot")
  Totalize (1, n, Long, sonic_amp_h_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_amp_h_f_Tot")
  Totalize (1, n, Long, sonic_sig_lck_f IMP (diag_sonic = NAN))
  FieldNames ("sonic_sig_lck_f_Tot")
  Totalize (1, n, Long, sonic_del_T_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_del_T_f_Tot")
  Totalize (1, n, Long, sonic_aq_sig_f  IMP (diag_sonic = NAN))
  FieldNames ("sonic_aq_sig_f_Tot")
  Totalize (1, n, Long, sonic_cal_err_f IMP (diag_sonic = NAN))
  FieldNames ("sonic_cal_err_f_Tot")
  '*** End of CSAT3B sonic data ***

  ' *** Variables used for correction ***
  '** Rotation-related variables
  Sample (1, alpha, IEEE4)                   'Pitch angle
  Sample (1, beta,  IEEE4)                   'Roll angle
  Sample (1, gamma, IEEE4)                   'Yaw angle

  '** Stability-related variables
  Sample (1, height_measurement,    IEEE4)   'Measurement height (m)
  Sample (1, height_canopy,         IEEE4)   'Canopy height (m).
  Sample (1, surface_type_text,    String)   'Crop, Grass, Forest, Shrub, Bare Land, Water, or Ice
  Sample (1, displacement_user,     IEEE4)   'Displacement height input by a user as priority for use in this program (0 is fefault and d is auto calculated and is used)
  Sample (1, d,                     IEEE4)   'Displacement height used by program (d = displacement_user if displacement_user <> 0; otherwise, it is auto calculated)
  Sample (1, roughness_user,        IEEE4)   'Roughness length input by a user as priority for use in this program (0 is fefault and z0 is auto calculated and is used)
  Sample (1, z0,                    IEEE4)   'Roughness length used by program z0 = displacement_user if roughness_user <> 0; otherwise, it is auto calculated
  Sample (1, z,                     IEEE4)   'Aerodynamic height
  Sample (1, MO_LENGTH,             IEEE4)   'Monin-Obukhov length
  Sample (1, ZL,                    IEEE4)   'Atmospheric boundary-layer stability.
  Sample (1, iteration_FreqFactor,  IEEE4)   'Iteration number in calculation of freq correction factor for U'W', V'W', and Ts'W'
  Sample (1, latitude,              IEEE4)
  Sample (1, longitude,             IEEE4)
  Sample (1, altitude,              IEEE4)

  '** Freq correction related variables

  Sample (1, FreqFactor_UW_VW,     IEEE4)  'Frequency correction factor for WU and WV
  Sample (1, FreqFactor_WT_SONIC,  IEEE4)  'Frequency correction factor for WT_SONIC

  ' *** End of correction related variables ***

  ' *** Output air properties calculated using measurements ***

  '*** Temperature and humidity probe data
  Sample  (1, rho_d_probe_Avg,     IEEE4)  'Density of dry air (g/m^3) and density of moist air (kg/m^3). Measured from temperature and humidity probe and amb_pressure
  Sample  (1, rho_a_probe_Avg,     IEEE4)

  '*** Beginning of other output data ***
  Average(1, panel_tmpr,     IEEE4, FALSE)
  FieldNames ("T_panel")
  Average  (1, batt_volt,    IEEE4, slowsequence_disable_f)
  FieldNames ("batt_volt")
  Totalize (1, n,            Long, slowsequence_disable_f)
  FieldNames ("slowsequence_Tot")

  '*** End of other output data ***

EndTable

#If CSAT3B_B Then
  DataTable (FluxB_Notes, TRUE, FLUX_SIZE_CPU)
    DataInterval (0, OUTPUT_INTV, Min, 0)
    TableFile ("CRD:"&"_FluxB_Notes_", 64, -1, 0,DAY_FLUX_CRD, day, 0, 0)

    '*** Beginning of CSAT sonic head data ***
    '*** Before coordinate rotation
    Sample (2, UxUyB_Cov,  IEEE4)    'UxUy_Cov and UxUz_Cov.
    Sample (1, UyUzB_Cov,  IEEE4)
    Sample (3, TsUxB_Cov,  IEEE4)    'TsUx_Cov, TsUy_Cov, and TsUz_Cov

    '** After coordinate rotations
    '   Ux is represented by U, Uy by V, Uz by W, and Ts by T_SONIC, if this rule is not applicable, _R is added for the indication of coordinate-rotated variable.
    Sample (1, USTARB_R,  IEEE4)    'Friction velocity after coordinate rotations.
    Sample (1, UB,        IEEE4)
    Sample (1, UB_SIGMA,  IEEE4)
    Sample (1, VB,        IEEE4)
    Sample (1, VB_SIGMA,  IEEE4)
    Sample (1, WB,        IEEE4)
    Sample (1, WB_SIGMA,  IEEE4)
    Sample (1, UVB_Cov,   IEEE4)
    Sample (1, UWB_Cov,   IEEE4)
    Sample (1, VWB_Cov,   IEEE4)
    Sample (1, UTB_SONIC_Cov, IEEE4)
    Sample (1, VTB_SONIC_Cov, IEEE4)
    Sample (1, WTB_SONIC_Cov, IEEE4)

    '*** _fc indicates after frequency corrections
    Sample (1, UWB_Cov_fc,       IEEE4)
    Sample (1, VWB_Cov_fc,       IEEE4)
    Sample (1, WTB_SONIC_Cov_fc, IEEE4)

    '** After coordinate rotations, freq corrections, and SND correction as indicated by WT_SONIC, fc, and SND.
    Sample (1, WTB_SONIC_Cov_fc_SND,  IEEE4)

    '** Summary of diagnosis flags of CSAT
    Totalize (1, nB, Long, sonicB_disable_f)  'Totalize the number of sonic samples without diagnostic flags
    FieldNames ("sonicB_samples")
    Sample (1, diag_sonicB_aggregate, Long)
    Totalize (1, nB, Long, diag_sonicB <> -1)
    FieldNames ("no_sonicB_head_Tot")
    Totalize (1, nB, Long, diag_sonicB <> NAN)
    FieldNames ("no_new_sonicB_data_Tot")
    Totalize (1, nB, Long, sonicB_amp_l_f   IMP (diag_sonicB = NAN))
    FieldNames ("sonicB_amp_l_f_Tot")
    Totalize (1, nB, Long, sonicB_amp_h_f   IMP (diag_sonicB = NAN))
    FieldNames ("sonicB_amp_h_f_Tot")
    Totalize (1, nB, Long, sonicB_sig_lck_f IMP (diag_sonicB = NAN))
    FieldNames ("sonicB_sig_lck_f_Tot")
    Totalize (1, nB, Long, sonicB_del_T_f   IMP (diag_sonicB = NAN))
    FieldNames ("sonicB_del_T_f_Tot")
    Totalize (1, nB, Long, sonicB_aq_sig_f  IMP (diag_sonicB = NAN))
    FieldNames ("sonicB_aq_sig_f_Tot")
    Totalize (1, nB, Long, sonicB_cal_err_f IMP (diag_sonicB = NAN))
    FieldNames ("sonicB_cal_err_f_Tot")
    '*** End of CSAT3B sonic data ***

    ' *** Variables used for correction ***
    '** Rotation-related variables
    Sample (1, alphaB, IEEE4)                   'Pitch angle
    Sample (1, betaB,  IEEE4)                   'Roll angle
    Sample (1, gammaB, IEEE4)                   'Yaw angle

    '** Stability-related variables
    Sample (1, height_measurementB,    IEEE4)   'Measurement height (m)
    Sample (1, height_canopy,         IEEE4)   'Canopy height (m).
    Sample (1, surface_type_text,    String)   'Crop, Grass, Forest, Shrub, Bare Land, Water, or Ice
    Sample (1, displacement_user,     IEEE4)   'Displacement height input by a user as priority for use in this program (0 is fefault and d is auto calculated and is used)
    Sample (1, dB,                     IEEE4)   'Displacement height used by program (d = displacement_user if displacement_user <> 0; otherwise, it is auto calculated)
    Sample (1, roughness_user,        IEEE4)   'Roughness length input by a user as priority for use in this program (0 is fefault and z0 is auto calculated and is used)
    Sample (1, z0B,                    IEEE4)   'Roughness length used by program z0 = displacement_user if roughness_user <> 0; otherwise, it is auto calculated
    Sample (1, zB,                     IEEE4)   'Aerodynamic height
    Sample (1, MO_LENGTHB,             IEEE4)   'Monin-Obukhov length
    Sample (1, ZLB,                    IEEE4)   'Atmospheric boundary-layer stability.
    Sample (1, iteration_FreqFactorB,  IEEE4)   'Iteration number in calculation of freq correction factor for U'W', V'W', and Ts'W'
    Sample (1, latitude,              IEEE4)
    Sample (1, longitude,             IEEE4)
    Sample (1, altitude,              IEEE4)

    '** Freq correction related variables

    Sample (1, FreqFactorB_UW_VW,     IEEE4)  'Frequency correction factor for WU and WV
    Sample (1, FreqFactorB_WT_SONIC,  IEEE4)  'Frequency correction factor for WT_SONIC

    ' *** End of correction related variables ***

    ' *** Output air properties calculated using measurements ***

    '*** Temperature and humidity probe data
    Sample  (1, rho_d_probe_Avg,     IEEE4)  'Density of dry air (g/m^3) and density of moist air (kg/m^3). Measured from temperature and humidity probe and amb_pressure
    Sample  (1, rho_a_probe_Avg,     IEEE4)

    '*** Beginning of other output data ***
    Average(1, panel_tmpr,     IEEE4, FALSE)
    FieldNames ("T_panel")
    Average  (1, batt_volt,    IEEE4, slowsequence_disable_f)
    FieldNames ("batt_volt")
    Totalize (1, n,            Long, slowsequence_disable_f)
    FieldNames ("slowsequence_Tot")

    '*** End of other output data ***

  EndTable
#EndIf

'******************************
'*** TIME SERIES DATA TABLE ***
'******************************
DataTable (Time_Series, TRUE, -1)
  DataInterval (0, SCN_INTV, mSec, 0)
  TableFile ("CRD:"&"_Time_Series_", 64, -1, 0, DAY_TSRS_CRD, day, 0, LastFileName_Time_Series)

  '*** Beginning of CSAT time series output ***
  Sample (3, Ux, IEEE4)
  FieldNames ("Ux,Uy,Uz")
  Sample (1, Ts, IEEE4)
  FieldNames ("T_SONIC")
  Sample (1, diag_sonic, Long)
  FieldNames ("diag_sonic")
  '*** End of CSAT time series output ***

EndTable

#If CSAT3B_B Then
  DataTable (Time_SeriesB, TRUE, -1)
    DataInterval (0, SCN_INTV, mSec, 0)
    TableFile ("CRD:"&"_Time_SeriesB_", 64, -1, 0, DAY_TSRS_CRD, day, 0, LastFileName_Time_SeriesB)

    '*** Beginning of CSAT time series output ***
    Sample (3, UBx, IEEE4)
    FieldNames ("UBx,UBy,UBz")
    Sample (1, TBs, IEEE4)
    FieldNames ("TB_SONIC")
    Sample (1, diag_sonicB, Long)
    FieldNames ("diag_sonicB")
    '*** End of CSAT time series output ***

  EndTable
#EndIf

'***********************
'*** DIAGNOSTIC DATA ***
'***********************
DataTable (diagnostic, TRUE, 1)
  Sample (6, sonic_amp_l_f,    Boolean)
EndTable

DataTable (diagnosticB, TRUE, 1)
  Sample (6, sonicB_amp_l_f,    Boolean)
EndTable
'*** End of output data tables ***


'*******************'
'*** SUBROUTINES ***'
'*******************'

Sub init
  flaginit = true

  Tice_OFST(1) = -0.01                 'Hier NTC Offsets einsetzen
  Tice_OFST(2) = -0.025
  Tice_OFST(3) = 0.1
  Tice_OFST(4) = 0
  Tice_OFST(5) = 0
  Tice_OFST(6) = -0.03
  Tice_OFST(7) = 0.046
  Tice_OFST(8) = 0.03
  Tice_OFST(9) = 0
  Tice_OFST(10) = 0
  Tice_OFST(11) = 0
  Tice_OFST(12) = 0
  Tice_OFST(13) = 0
  Tice_OFST(14) = 0
  Tice_OFST(15) = 0
  Tice_OFST(16) = 0

EndSub

'*** Subroutines for coordinate rotation corrections  ***
' 1. Two Subroutines for Double Rotations
'    a. Rotations for momentum covariance
'    b. Rotations for covariance of momentum with scalar variables

' Definition of double rotation: the 1st AND 2nd rotations in Tanner & Thurtell (1969)
'      a. Counterclockwise about the instrument z-axis for Gamma degrees
'      b. Counterclockwise about the intermediate y-axis for Alpha degrees
'         [Originally clockwise, but in these subroutines following Wilczak et al. (2001) convention of counterclockwise rotation]

'  SUBROUTINE                     MAIN PROGRAM
'  alph                           alpha
'  bet                            beta
'  gamm                           gamma
'  U_mean, V_mean, W_mean         Ux_Avg, Uy_Avg, Uz_Avg
'  UU_cov, VV_cov, WW_cov         Ux_SIGMA, Uy_SIGMA, Uz_SIGMA
'  UVcov,  UWcov,  VWcov          UxUy_cov, UxUz_cov, UyUz_cov
'  Umean_R, Vmean_R, Wmean_R      U, V, W
'  UUcov_R, VVcov_R, WWcov_R      U_SIGMA, V_SIGMA, W_SIGMA
'  UVcov_R, UWcov_R, VWcov_R      UV_Cov, UW_Cov, VW_Cov

' Sub: Rotation12_Momentum (where "12" indicates the 1st and 2nd rotations)
'      Transform the expression of momentum variables in the instrument coordinate system to the natural wind coordinate system.
Sub Rotation12_Momentum(alph, gamm,   U_mean,  V_mean,  W_mean,  UU_cov,  VV_cov,  WW_cov,  UVcov,   UWcov,   VWcov,   Umean_R, Vmean_R, Wmean_R, UUcov_R, VVcov_R, WWcov_R, UVcov_R, UWcov_R, VWcov_R )

  ' For efficient calculations, efficient use of memory, and shorter expressions in the following equations, the variables of "UWcov_R" and
  ' "VWcov_R" are used first as intermediate variables before both variables are needed for their own roles.
  UWcov_R =  UU_cov*COS(gamm)*COS(gamm) + VV_cov*SIN(gamm)*SIN(gamm)
  VWcov_R =  UWcov*COS(gamm) + VWcov*SIN(gamm)

  ' a. ROTATIONS FOR MEAN TERMS
  Umean_R = COS(alph)*(U_mean*COS(gamm) + V_mean*SIN(gamm)) - W_mean*SIN(alph)
  Vmean_R = 0
  Wmean_R = SIN(alph)*(U_mean*COS(gamm) + V_mean*SIN(gamm)) + W_mean*COS(alph)

  ' b. ROTATIONS FOR VARIANCE TERMS
  UUcov_R = COS(alph)*COS(alph)*UWcov_R +   WW_cov*SIN(alph)*SIN(alph) + UVcov*COS(alph)*COS(alph)*SIN(2*gamm) -   SIN(2*alph)*VWcov_R

  VVcov_R = UU_cov*SIN(gamm)*SIN(gamm) + VV_cov*COS(gamm)*COS(gamm) - UVcov*SIN(2*gamm)

  WWcov_R = SIN(alph)*SIN(alph)*UWcov_R  +   WW_cov*COS(alph)*COS(alph) + UVcov*SIN(alph)*SIN(alph)*SIN(2*gamm) +   SIN(2*alph)*VWcov_R

  ' c. ROTATIONS FOR COVARIANCE TERMS
  UVcov_R = -0.5*(UU_cov - VV_cov)*COS(alph)*SIN(2*gamm) +   UVcov*COS(alph)*COS(2*gamm) +   SIN(alph)*(UWcov*SIN(gamm) - VWcov*COS(gamm))

  UWcov_R =  0.5*SIN(2*alph)*(UWcov_R - WW_cov + UVcov*SIN(2*gamm)) + COS(2*alph)*VWcov_R

  VWcov_R = -SIN(alph)*(0.5*(UU_cov - VV_cov)*SIN(2*gamm)-UVcov*COS(2*gamm))-   COS(alph)*(UWcov*SIN(gamm) - VWcov*COS(gamm))

EndSub

' Sub: Rotation12_Scalar_Covariance [where "12" indicates the 1st and 2nd rotations in Tanner & Thurtell (1969)]
'      Transform the expression of variance of scalar with momentum variables in the instrument coordinate system
'      to the natural wind coordinate system in x and y.

Sub Rotation12_Scalar_Covariance(alph, gamm, SU_cov,  SV_cov, SW_cov, SUcov_R, SVcov_R, SWcov_R)

  SUcov_R =  COS(alph)*(SU_cov*COS(gamm) + SV_cov*SIN(gamm)) - SW_cov*SIN(alph)

  SVcov_R = -SU_cov*SIN(gamm) + SV_cov*COS(gamm)

  SWcov_R =  SIN(alph)*(SU_cov*COS(gamm) + SV_cov*SIN(gamm)) + SW_cov*COS(alph)

EndSub

' 2. Sub-programs for Planar Fit Rotations [Wilczak et al. (2001)]
'    a. Rotations for momentum covariance
'    b. Rotations for covariance of momentum variable with scalar variables

'    Planar Fit Rotations
'      a. Counterclockwise rotation about the instrument y-axis for Alph degrees  [2nd rotation in Tanner and Thurtell (1969), clockwise]
'      b. Counterclockwise rotation about the intermediate x-axis for Beta degrees [3rd rotation in Tanner and Thurtell (1969)]

' Sub: Rotation23_Momentum [where "23" indicates the 2nd and 3rd rotations in Tanner & Thurtell (1969)]
Sub Rotation23_Momentum(alph, bet,   U_mean,  V_mean,  W_mean,  UU_cov,  VV_cov,  WW_cov,  UVcov,   UWcov,   VWcov,   Umean_R, Vmean_R, Wmean_R, UUcov_R, VVcov_R, WWcov_R, UVcov_R, UWcov_R, VWcov_R )

  ' For efficient calculations, efficient use of memory, and shorter expressions in the following equations, the four variables of Wmean_R, UVcov_R,
  ' UWcov_R, and VWcov_R are used first as intermediate variables for repeated terms before the four variables are needed for their own roles.
  Wmean_R =  V_mean*SIN(bet) - W_mean*COS(bet)
  UVcov_R =  VV_cov*SIN(bet)*SIN(bet) - VWcov*SIN(2*bet) + WW_cov*COS(bet)*COS(bet)
  UWcov_R =  UVcov*SIN(bet) - UWcov*COS(bet)
  VWcov_R =  UVcov*COS(bet) + UWcov*SIN(bet)

  ' a. ROTATIONS FOR MEAN TERMS
  Umean_R = U_mean*COS(alph) +  Wmean_R*SIN(alph)
  Vmean_R = V_mean*COS(bet)  +  W_mean *SIN(bet)
  Wmean_R = U_mean*SIN(alph) -  Wmean_R*COS(alph)

  ' b. ROTATIONS FOR VARIANCE TERMS
  UUcov_R = UU_cov*COS(alph)*COS(alph) + UVcov_R*SIN(alph)*SIN(alph) + UWcov_R*SIN(2*alph)

  VVcov_R = VV_cov*COS(bet)*COS(bet)   + VWcov*SIN(2*bet)            + WW_cov*SIN(bet)*SIN(bet)

  WWcov_R = UU_cov*SIN(alph)*SIN(alph) + UVcov_R*COS(alph)*COS(alph) - UWcov_R*SIN(2*alph)

  ' c. ROTATIONS FOR COVARIANCE TERMS
  UVcov_R = SIN(alph)*(0.5*(VV_cov - WW_cov)*SIN(2*bet)- VWcov*COS(2*bet)) + COS(alph)*VWcov_R

  UWcov_R = 0.5*SIN(2*alph)*(UU_cov - VV_cov*SIN(bet)*SIN(bet) - WW_cov*COS(bet)*COS(bet) + VWcov*SIN(2*bet)) - COS(2*alph)*UWcov_R

  VWcov_R = -COS(alph)*(0.5*(VV_cov - WW_cov)*SIN(2*bet) - VWcov*COS(2*bet))+SIN(alph)*VWcov_R

EndSub


' Sub: Rotation23_Scalar_Covariance [where "23" indicates the 2nd and 3rd rotations in Tanner & Thurtell (1969)]
'      Transform the expression of covariance of scalar with momentum variables in the instrument coordinate system
'      to the natural wind coordinate system in z.

Sub Rotation23_Scalar_Covariance(alph, bet, _
  SU_cov,   SV_cov,   SW_cov, _
  SU_cov_R, SV_cov_R, SW_cov_R)

  SU_cov_R =  SU_cov*COS(alph) + SIN(alph)*(SV_cov*SIN(bet) - SW_cov*COS(bet))

  SV_cov_R =  SV_cov*COS(bet)  + SW_cov*SIN(bet)

  SW_cov_R =  SU_cov*SIN(alph) - COS(alph)*(SV_cov*SIN(bet) - SW_cov*COS(bet))

EndSub

'*** End of subroutnes for coordinate rotation corrections  ***


'*** Subroutine to calculate displacement height, roughness length, and aerodynamic height ***

'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' S_type                 Surface_type
' d_user                 displacement_user
' z0_user                Roughness_user
' h_canopy               height_canopy
' h_measurement          height_measurement
' displacement           d
' Roughness              z0
' h_aerodynamic          z (sensing height above the ground - d)

Sub  Displacement_roughness_heights (S_type, d_user, z0_user, h_canopy, h_measurement, displacement, roughness, h_aerodynamic)
  ' Calculate displacement height, roughness length, and aerodynamic height
  If ((S_type = CROP) OR (S_type = GRASS)) Then              'Crop and grass

    Select Case h_canopy
    Case Is = 0.0
      displacement = 0.0                                     'Default w/o canopy
      roughness    = 0.01                                    'Default w/o canopy
    Case Is > 0.0
      displacement = 10.0^(0.979*LOG10(h_canopy)-0.154)      'Crop or grass canopy, Eq. 4.5, page 138 in Rosenberg et al. (1983)
      roughness    = 10.0^(0.977*LOG10(h_canopy)-0.883)      'Crop or grass canopy, Eq. 4.4, page 137 in Rosenberg et al. (1983)
    EndSelect

  EndIf

  If ((S_type = FOREST) OR (S_type = SHRUB)) Then            'Forest and Shrub
    displacement = 2.0*h_canopy/3.0                          'Forest canopy, 2/3 rule, page 116, Oke, 1987
    roughness    = 0.06*h_canopy                             'Forest canopy, Jarvis et al. (1976) ans Raupach et al. (1991)
  EndIf

  If ((S_type = BARELAND) OR (S_type = WATER) OR (S_type = ICE)) Then   'Bare land, water, or ice
    displacement = 0.0                                                  'Default w/o canopy
    roughness    = 0.01                                                 'Default w/o canopy
  EndIf

  If (d_user <> 0.0)  Then displacement = d_user             'User preferred has a priority
  If (z0_user <> 0.0) Then roughness    = z0_user            'User preferred has a priority

  h_aerodynamic = h_measurement - displacement
EndSub
'*** End of subroutine to calculate displacement height, roughness length, and aerodynamic height ***


'*** Subroutines for freq correction factors ***

'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
' height_aerodynamic     z
' stability              ZL
' U_total                WS_rslt
' freq_factor            FreqFactor_uw_vw

' *** Freq factor for UW and VW
Sub FreqFactorCSAT_UW_VW_BA_LA (height_aerodynamic, stability, U_total, freq_factor)
  'Variables used inside subrotine
  Dim cosp_uw                       'Cospectrum of U or V with W
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for WW
  Dim tran_func_LA_uu               'Transfer function of line averaging for UU or VV

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of U or V with W
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of U or V with W
  Dim weight                        'Weight factor in numerical integration of Composite Simpson's Rule
  Dim J As Long                     'Iteration index. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Define intermediate variables to reduce the repeat computation inside iteration loops
  Dim zu                            'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                       'PATH_LENGTH_CSAT/U_total
  Dim PI2_pu_freq_csat              'Intermediate variable 2*PI*pu_csat*freq
  Dim A_uw, B_uw                    'Parameters in the cospectrum of U with W for stable condition

  If ((stability <> NaN) AND (U_total <> NaN)) Then
    'Reset variables
    freq_factor_numerator   = 0.0
    freq_factor_denominator = 0.0

    'Prepare calculations
    zu      = height_aerodynamic/U_total
    pu_csat = PATH_LENGTH_CSAT/U_total

    'Calculate parameters in the cospectrum of U with W for stable condition
    Select Case stability
    Case Is > 0.0 AND Is <= 4.0
      A_uw =  0.124*((1.0 + 7.9*stability)^0.75)       'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_uw = 23.252*((1.0 + 7.9*stability)^(-0.825))   'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4   'Similarity functions are defined in a range of stability from -2 to 2 (pgs 17, 28, 41~43, Kaimal & Finnigan 1994). Extended to 4 as shown in Fig 5.23 in Stull (1988)
      A_uw =  0.124*((1.0 + 7.9*4.0)^0.75)             'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_uw = 23.252*((1.0 + 7.9*4.0)^(-0.825))         'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    ' Calculate correction factor
    For J = 0 To FREQ_BIN
      freq  = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = 2.0*PI*pu_csat*freq

      '** Cospectrum
      If stability > 0.0 Then
        cosp_uw = freq*zu/(A_uw + B_uw*(freq*zu)^2.1)             'Eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                     'Eq. 26 in Moore (1986), eqs. 17 & 18 in Moncrieff et al (1997), eq. 2.85 in Dijk (2002)
        Case Is < 0.24
          cosp_uw = 20.78*freq*zu/((1.0 + 31.0*freq*zu)^1.575)
        Case Is >= 0.24
          cosp_uw = 12.66*freq*zu/((1.0 + 9.6*freq*zu)^2.4)
        EndSelect
      EndIf

      '** Transfer function
      tran_func_BA    = 1.0 - (SIN (10800*OUTPUT_INTV*freq)/(PI*60*OUTPUT_INTV*freq))^2   'Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Inside SIN(), angle degrees must be used.
      tran_func_LA_uu = (SIN (180.0*pu_csat*freq)/(PI*pu_csat*freq))^2.0                  'Eq. 2.70 in Dijk (2002)

      If PI2_pu_freq_csat >= 0.01 Then
        tran_func_LA_ww = (4.0/PI2_pu_freq_csat)*(1.0 + (PI2_pu_freq_csat + 3.0)/(2.0*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) - 3.0/(2.0*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), pg. 610 in Moncrieff et al. (1997)
      Else
        tran_func_LA_ww = 1.0 'Due to single precision in CR6, this term cannot be calculated when the 2*Pi*dimensionless_freq < 0.01. This is an approximation. The error in the approximation is < 0.001
      EndIf

      ' Composite Simpson's Rule
      weight = 2.0 + 2.0*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator   += weight*cosp_uw

      freq_factor_denominator += weight*cosp_uw*tran_func_BA*SQR(tran_func_LA_uu*tran_func_LA_ww)

    Next J

    '** correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1.0
  EndIf
EndSub

' *** Frequency factor for wTs

'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
' height_aerodynamic     z
' Stability              ZL
' U_total                WS_rslt
' tran_func_LA_Dijk()    tran_func_LA_data_Dijk()
' freq_factor            FreqFactor_WT_SONIC

Sub FreqFactorCSAT_wTs_BA_LA (height_aerodynamic, stability, U_total, tran_func_LA_Dijk(2,35), freq_factor)
  'Variables used inside subrotine
  Dim cosp_wTs                 'Copectrum of Ts (T_SONIC) with W
  Dim tran_func_BA             'Transfer function of block averaging for covariance
  Dim Tran_func_LA_wTs         'Transfer function of line averaging for WT_SONIC

  Dim freq                     'Cyclic frequency
  Dim freq_factor_numerator    'Numerator to calculate the freq correction factor for covariance of T_SONIC with W
  Dim freq_factor_denominator  'Denominator to calculate the freq correction factor for covariance of T_SONIC with W
  Dim weight                   'Weight factor in numerical integration of Composite Simpson's Rule
  Dim J  As Long               'Index for the outmost iteration. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  Dim jj As Long               'Index for the iteration inside the outmost iteration
  Dim Prev_jj As Long

  'Define following variables for saving computation time by calculating these once outside iteration loops or reduce the repeat computations
  Dim zu                       'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                  'PATH_LENGTH_CSAT/U_total
  Dim PI2_pu_freq_csat         'Intermediate variable 2*PI*pu_csat*freq
  Dim A_wTs, B_wTs             'Parameters in the cospectrum of T_SONIC with W in stable condition

  If ((stability <> NaN) AND (U_total <> NaN)) Then

    'Reset variables
    freq_factor_numerator   = 0.0
    freq_factor_denominator = 0.0
    Prev_jj                 = 1

    'Prepare calculations
    zu      = height_aerodynamic/U_total
    pu_csat = PATH_LENGTH_CSAT/U_total

    'Calculate parameters in the cospectrum of W with T_SONIC for stable condition
    Select Case stability
    Case Is > 0.0 AND Is <= 4.0
      A_wTs = 0.2840*((1.0 + 6.4*stability)^0.75)               'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      B_wTs = 9.3447*((1.0 + 6.4*stability)^(-0.825))           'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4.0  'Similarity functions are defined in a range of stability (ZL) from -2 to 2 (pgs 28, 41~43, Kaimal & Finnigan 1994).  Extended to 4 as shown in Fig 5.23 in Stull (1988)
      A_wTs = 0.2840*((1.0 + 6.4*4.0)^0.75)                     'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      B_wTs = 9.3447*((1.0 + 6.4*4.0)^(-0.825))                 'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Start calculations for correction factor
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = 2.0*PI*pu_csat*freq

      '**Cospectrum
      If (stability > 0.0) Then
        cosp_wTs   = zu*freq/(A_wTs + B_wTs*(zu*freq)^2.1)      'Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                     'Eq.25 in Moore (1986), eqs.15 & 16 in Moncrieff et al. (1997), eq.2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wTs = 12.92*zu*freq/((1 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wTs =  4.378*zu*freq/((1 + 3.8*zu*freq)^2.4)     '4.378 from original source Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '**Transfer function
      tran_func_BA = 1.0 - (SIN (10800*OUTPUT_INTV*freq)/(PI*60*OUTPUT_INTV*freq))^2.0   'Eq.4 in Kaimal et al (1989), Eq.3 in Massman (2000)

      For jj = Prev_jj To 34
        If  (PI2_pu_freq_csat >= tran_func_LA_Dijk(1,jj)) AND  (PI2_pu_freq_csat < tran_func_LA_Dijk(1, jj+1)) Then

          Tran_func_LA_wTs = tran_func_LA_Dijk(2,jj) + (PI2_pu_freq_csat - tran_func_LA_Dijk(1,jj))*(tran_func_LA_Dijk(2,jj+1)-tran_func_LA_Dijk(2,jj))/(tran_func_LA_Dijk(1,jj+1) - tran_func_LA_Dijk(1,jj))
          Prev_jj = jj

          ExitFor
        EndIf
      Next jj

      If (PI2_pu_freq_csat >= tran_func_LA_Dijk(1, 35)) Then Tran_func_LA_wTs = tran_func_LA_Dijk(2, 35)

      'Composite Simpson's Rule
      weight = 2.0 + 2.0*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in sequential order.

      freq_factor_numerator   += weight*cosp_wTs
      freq_factor_denominator += weight*cosp_wTs*tran_func_BA*Tran_func_LA_wTs

    Next J

    '**Correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1.0
  EndIf
EndSub




'*** Beginning of subroutines for data quality classification ***
'a. Data quality grading for momentum flux using steady state test, integral turbulence characteristics, and horizontal wind orientation relative to the CSAT coordinate system
'   Foken et al. (2012)
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  Planar_fit            Planar_Fit_flg
'  stability             ZL
'  SIGMA_u               U_SIGMA
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  lat                   latitude
'  wnd_dir               WD_SONIC
'  RNS                   RN_UW_VW_cov      RNS: Relative Non-Stationarity
'  QC                    TAU_QC            Quality Classes 1 to 9.

Sub Data_Quality_SSITC_w_WndDir_Momentum (Planar_Fit As Boolean, stability, SIGMA_u, SIGMA_w, U_star, lat, wnd_dir, RNS, QC)
  ' Test on turbulence conditions in development
  Dim    ITC_uw(2)                              'ITC: Integral Turbulence Characteristic. This array is used in instruction MaxSpa to select max
  Alias  ITC_uw(1) = ITCuu                      'ITC for variance of horizontal velocity
  Alias  ITC_uw(2) = ITCww                      'ITC for variance of vertical velocity

  Dim    ITC_uw_max(2)                          'for use of instruction MaxSpa. Hold the max and the index of max location
  Alias  ITC_uw_max(1) = ITC_uu_ww              'ITC for momentum flux
  Alias  ITC_uw_max(2) = ITC_uu_ww_max_seq      'the index of max location

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean                'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean                'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(3)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Momentum_1st_Occurrence   'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Momentum_1st_Occurrence   'The lowest possible grade of ITC in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(3) = Wnd_Momentum_1st_Occurrence   'The lowest possible grade of wind direction in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'for use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Reset
  QC = 0

  '1. Relative Non-Stationarity
  'Possible grade for Relative Non-Stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS < 10.0))

  For J = 1 To 8
    RNS_Momentum_1st_Occurrence = -J *RNS_category(J)
    If (RNS_Momentum_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                    'Omega: earth angular velocity

  Select Case stability
  Case Is <= -0.032
    ITCuu = 4.15*ABS(stability)^0.125                      'Table 4.2 (Foken et al. 2012)
    ITCww = 2.00*ABS(stability)^0.125                      'Table 4.2 (Foken et al. 2012)

  Case Is > -0.032 AND Is <= 0
    ITCuu = 2.7                                            'Table 4.2 (Foken et al. 2012)
    ITCww = 1.3                                            'Table 4.2 (Foken et al. 2012)

  Case Is < 0.4 AND Is > 0
    ITCuu = 0.44*LN(ABS(Coriolis_parameter)/U_star) + 6.3  'Table 4.3 (Foken et al. 2012)
    ITCww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 4.3 (Foken et al. 2012)

  Case Is >= 0.4
    ITCuu = -(SIGMA_u/U_star)/9.1                           'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
    ITCww = -(SIGMA_w/U_star)/9.1                           'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect

  ITCuu = ABS((ITCuu - (SIGMA_u/U_star))/ITCuu)              'In fraction
  ITCww = ABS((ITCww - (SIGMA_w/U_star))/ITCww)              'In fraction

  If (NOT Planar_Fit) Then
    'If double rotations, both the max of ITC_uu and ITC_ww is used as ITC_uu_ww.
    MaxSpa(ITC_uu_ww, 2, ITCuu)                               'Max is used for momentum flux related to uw and vw
  Else
    'If planar fit, only ITC_ww is used as ITC_uu_ww.
    ITC_uu_ww = ITCww
  EndIf

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_uu_ww < 0.31)
  ITC_category(2) = (ITC_uu_ww < 0.31)
  ITC_category(3) = ((ITC_uu_ww >= 0.31) AND (ITC_uu_ww < 0.76))
  ITC_category(4) = (ITC_uu_ww < 0.31)
  ITC_category(5) = ((ITC_uu_ww >= 0.31) AND (ITC_uu_ww < 1.01))
  ITC_category(6) = ((ITC_uu_ww >= 0.76) AND (ITC_uu_ww < 1.01))
  ITC_category(7) = ((ITC_uu_ww >= 1.01) AND (ITC_uu_ww < 2.51))
  ITC_category(8) = ((ITC_uu_ww >= 2.51) AND (ITC_uu_ww < 10.00))

  For J = 1 To 8
    ITC_Momentum_1st_Occurrence = -J *ITC_category(J)
    If (ITC_Momentum_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '3. Wind direction
  'The lowest possible grade of wind direction in the overall grade system
  If ((wnd_dir < 151.0) OR (wnd_dir > 209.0)) Then
    Wnd_Momentum_1st_Occurrence = 1
  ElseIf (((wnd_dir >= 151.0) AND (wnd_dir < 171.0)) OR ((wnd_dir > 189.0) AND (wnd_dir <= 209.0)))
    Wnd_Momentum_1st_Occurrence = 7
  ElseIf ((wnd_dir >= 171.0) AND (wnd_dir <= 189.0))
    Wnd_Momentum_1st_Occurrence = 0
  EndIf

  '1st case
  If ((RNS_Momentum_1st_Occurrence = 0) OR (ITC_Momentum_1st_Occurrence =0) OR (Wnd_Momentum_1st_Occurrence = 0)) Then        'Any in category 9 (0 used for 9 now)
    QC = 9

    '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 3, RNS_Momentum_1st_Occurrence)
    QC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_uu_ww = NaN) OR (wnd_dir = NaN)) AND (QC = 9)) Then  QC = NaN

EndSub

'b. Data quality grading for momentum flux using steady state test and integral turbulence characteristics.
'   Foken et al. (2004).

'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  Planar_fit            Planar_Fit_flg
'  stability             ZL
'  SIGMA_u               U_SIGMA
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  lat                   latitude
'  RNS                   RN_UW_VW_cov      RNS: Relative Non-Stationarity
'  TAU_SSITC             TAU_SSITC_TEST    Quality Classes 1 to 9.

Sub Data_Quality_SSITC_wo_WndDir_Momentum (Planar_Fit As Boolean, stability, SIGMA_u, SIGMA_w, U_star, lat, RNS, TAU_SSITC)
  ' Test on turbulence conditions in development
  Dim    ITC_uw(2)                              'ITC: Integral Turbulence Characteristic. This array is used in instruction MaxSpa to select max
  Alias  ITC_uw(1) = ITCu                       'ITC for variance of horizontal velocity
  Alias  ITC_uw(2) = ITCw                       'ITC for variance of vertical velocity

  Dim    ITC_uw_max(2)                          'for use of instruction MaxSpa. Hold the max and the index of max location
  Alias  ITC_uw_max(1) = ITC_u_w                'ITC for momentum flux
  Alias  ITC_uw_max(2) = ITC_u_w_max_seq        'the index of max location

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean                'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean                'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(2)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Momentum_1st_Occur   'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Momentum_1st_Occur   'The lowest possible grade of ITC in the overall grade system

  Dim Lowest_Seq_Max(2)                                         'for use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                 'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Reset
  TAU_SSITC = 0

  '1. Relative Non-Stationarity
  'Possible grade for Relative Non-Stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS  < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Momentum_1st_Occur = -J *RNS_category(J)
    If (RNS_Momentum_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                   'Omega: earth angular velocity

  Select Case stability
  Case Is <= -0.032
    ITCu = 4.15*ABS(stability)^0.125                      'Table 9.1 (Foken et al. 2004)
    ITCw = 2.00*ABS(stability)^0.125                      'Table 9.1 (Foken et al. 2004)

  Case Is > -0.032 AND Is <= 0
    ITCu = 2.7                                            'Table 9.1 (Foken et al. 2004)
    ITCw = 1.3                                            'Table 9.1 (Foken et al. 2004)

  Case Is < 0.4 AND Is > 0
    ITCu = 0.44*LN(ABS(Coriolis_parameter)/U_star) + 6.3  'Table 9.2 (Foken et al. 2004)
    ITCw = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 9.2 (Foken et al. 2004)

  Case Is >= 0.4
    ITCu = -(SIGMA_u/U_star)/9.1                          'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
    ITCw = -(SIGMA_w/U_star)/9.1                          'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect

  ITCu = ABS((ITCu - (SIGMA_u/U_star))/ITCu)              'In fraction
  ITCw = ABS((ITCw - (SIGMA_w/U_star))/ITCw)              'In fraction

  If (NOT Planar_Fit) Then
    'If double rotations, the max of ITC_u and ITC_w is used as ITC_u_w.
    MaxSpa(ITC_u_w, 2, ITCu)                             'Max is used for momentum flux related to uw and vw
  Else
    'If planar fit, only ITC_w is used as ITC_u_w.
    ITC_u_w = ITCw
  EndIf

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_u_w < 0.31)
  ITC_category(2) = (ITC_u_w < 0.31)
  ITC_category(3) = ((ITC_u_w >= 0.31) AND (ITC_u_w < 0.76))
  ITC_category(4) = (ITC_u_w < 0.31)
  ITC_category(5) = ((ITC_u_w >= 0.31) AND (ITC_u_w < 1.01))
  ITC_category(6) = ((ITC_u_w >= 0.76) AND (ITC_u_w < 1.01))
  ITC_category(7) = ((ITC_u_w >= 1.01) AND (ITC_u_w < 2.51))
  ITC_category(8) = ((ITC_u_w >= 2.51) AND (ITC_u_w < 10.00))

  For J = 1 To 8
    ITC_Momentum_1st_Occur = -J *ITC_category(J)
    If (ITC_Momentum_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '1st case
  If  ((RNS_Momentum_1st_Occur = 0) OR (ITC_Momentum_1st_Occur =0)) Then        'Any in category 9 (0 used for 9 now)
    TAU_SSITC = 9

    '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 2, RNS_Momentum_1st_Occur)
    TAU_SSITC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_u_w = NaN)) AND (TAU_SSITC = 9)) Then  TAU_SSITC = NaN

EndSub

Sub Data_Quality_SSITC_w_WndDir_Scalar (stability, SIGMA_w, U_star, Ts_std, T_star, lat, wnd_dir, RNS, QC)
  ' Test on developed turbulence conditions
  Dim ITC_TsTs                             'ITC (Integral Turbulence Characteristics) for variance of T_SONIC.
  Dim ITC_wTs                              'ITC for variance of vertical wind speed with T_SONIC.
  Dim ITC_ww                               'ITC for variance of vertical wind.

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean           'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean           'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(3)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Scalar_1st_Occurrence     'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Scalar_1st_Occurrence     'The lowest possible grade of ITC in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(3) = Wnd_Scalar_1st_Occurrence     'The lowest possible grade of wind direction in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'For use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Reset
  QC = 0

  '1. Relative Non-Stationarity
  'Possible Grade for relative non-stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS  < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Scalar_1st_Occurrence = -J *RNS_category(J)
    If (RNS_Scalar_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                    'Omega: earth angular velocity

  'Test on developed turbulence conditions for a scalar flux using the integral turbulence characteristic
  Select Case stability
  Case Is <= -0.032
    ITC_ww = 2.00*ABS(stability)^0.125                       'Table 4.2 (Foken et al. 2012)

  Case Is > -0.032 AND Is <= 0.0
    ITC_ww = 1.3                                             'Table 4.2 (Foken et al. 2012)

  Case Is < 0.4 AND Is > 0.0
    ITC_ww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 4.3 (Foken et al. 2012)

  Case Is >= 0.4
    ITC_ww = -(SIGMA_w/U_star)/9.1                          'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect

  ITC_ww = ABS((ITC_ww - (SIGMA_w/U_star))/ITC_ww)        'In fraction

  Select Case stability
  Case Is < -1.0
    ITC_TsTs = ABS(stability)^(-1/3)                        'Table 4.2 (Foken et al. 2012)

  Case Is <= -0.062 AND Is >= -1.0
    ITC_TsTs = ABS(stability)^(-0.25)                       'Table 4.2 (Foken et al. 2012)

  Case Is < 0.02 AND Is > -0.062
    ITC_TsTs = 0.5*ABS(stability)^(-0.50)                   'Table 4.2 (Foken et al. 2012)

  Case  Is >= 0.02 AND Is < 1.0
    ITC_TsTs = 1.4*stability^(-0.25)                        'Table 4.2 (Foken et al. 2012)

  Case Is >= 1.0
    ITC_TsTs = -(Ts_std/ABS(T_star))/9.1                    'Classify it into grade 9 when ZL >= 1
  EndSelect

  ITC_TsTs = ABS((ITC_TsTs - Ts_std/ABS(T_star))/ITC_TsTs)  'in fraction

  ITC_wTs = IIF ( (ITC_TsTs > ITC_ww), ITC_TsTs, ITC_ww)

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_wTs < 0.31)
  ITC_category(2) = (ITC_wTs < 0.31)
  ITC_category(3) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 0.76))
  ITC_category(4) = (ITC_wTs < 0.31)
  ITC_category(5) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 1.01))
  ITC_category(6) = ((ITC_wTs >= 0.76) AND (ITC_wTs < 1.01))
  ITC_category(7) = ((ITC_wTs >= 1.01) AND (ITC_wTs < 2.51))
  ITC_category(8) = ((ITC_wTs >= 2.51) AND (ITC_wTs < 10.00))

  For J = 1 To 8
    ITC_Scalar_1st_Occurrence = -J *ITC_category(J)
    If (ITC_Scalar_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '3. Wind direction
  'The lowest possible grade of wind direction in the overall grade system
  If ((wnd_dir <= 151.0) OR (wnd_dir >= 209.0)) Then
    Wnd_Scalar_1st_Occurrence = 1
  ElseIf (((wnd_dir > 151.0) AND (wnd_dir <= 171.0)) OR ((wnd_dir >= 189.0) AND (wnd_dir < 209.0)))
    Wnd_Scalar_1st_Occurrence = 7
  ElseIf ((wnd_dir > 171.0) AND (wnd_dir < 189.0))
    Wnd_Scalar_1st_Occurrence = 0
  EndIf

  '1st case
  If  ((RNS_Scalar_1st_Occurrence = 0) OR (ITC_Scalar_1st_Occurrence = 0) OR (Wnd_Scalar_1st_Occurrence = 0)) Then        'Any in category 9 (0 used for 9, here)
    QC = 9

    '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 3, RNS_Scalar_1st_Occurrence)
    QC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_wTs = NaN) OR (wnd_dir = NaN)) AND (QC = 9)) Then  QC = NaN
EndSub


'd. Data quality grading for scalar flux using steady state test and integral turbulence characteristics.
'   Foken et al. (2004)

'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
'  stability             ZL
'  SIGMA_w               W_SIGMA
'  U_star                USTAR
'  SIGMA_Ts              T_SONIC_SIGMA
'  T_star                TSTAR
'  lat                   latitude
'  RNS                   RN_WT_SONIC_cov, RN_WCO2_Cov, or RN_WH2O_Cov                Relative Non-Stationarity
'  SSITC                 Fc_SSITC_TEST, LE_SSITC_TEST, ET_SSITC_TEST, or H_SSITC     Quality Classes 1 to 9.

Sub Data_Quality_SSITC_wo_WndDir_Scalar (stability, SIGMA_w, U_star, SIGMA_Ts, T_star, lat, RNS, SSITC)
  ' Test on developed turbulence conditions
  Dim ITC_TsTs                             'ITC (Integral Turbulence Characteristics) for variance of T_SONIC.
  Dim ITC_wTs                              'ITC for variance of vertical wind speed with T_SONIC.
  Dim ITC_ww                               'ITC for variance of vertical wind.

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean           'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean           'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(2)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Scalar_1st_Occur          'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Scalar_1st_Occur          'The lowest possible grade of ITC in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'For use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The uppercase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowercase (e.g. J/s m^2) throughout the program.

  'Reset
  SSITC = 0

  '1. Relative Non-Stationarity
  'Possible Grade for relative non-stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.16)
  RNS_category(2) = ((RNS >= 0.16) AND (RNS < 0.31))
  RNS_category(3) = (RNS  < 0.31)
  RNS_category(4) = ((RNS >= 0.31) AND (RNS < 0.76))
  RNS_category(5) = (RNS  < 0.76)
  RNS_category(6) = ((RNS >= 0.76) AND (RNS < 1.01))
  RNS_category(7) = ((RNS >= 1.01) AND (RNS  < 2.51))
  RNS_category(8) = ((RNS >= 2.51) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Scalar_1st_Occur = -J *RNS_category(J)
    If (RNS_Scalar_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Characteristic
  Coriolis_parameter = 2.0*Omega*SIN(lat)                    'Omega: earth angular velocity

  'Test on developed turbulence conditions for scalar flux using the integral turbulence characteristic
  Select Case stability
  Case Is <= -0.032
    ITC_ww = 2.00*ABS(stability)^0.125                       'Table 9.1 (Foken et al. 2004)

  Case Is > -0.032 AND Is <= 0.0
    ITC_ww = 1.3                                             'Table 9.1 (Foken et al. 2004)

  Case Is < 0.4 AND Is > 0.0
    ITC_ww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1   'Table 9.1 (Foken et al. 2004)

  Case Is >= 0.4
    ITC_ww = -(SIGMA_w/U_star)/9.1                           'Model unavailable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect
  ITC_ww = ABS((ITC_ww - (SIGMA_w/U_star))/ITC_ww)           'In fraction

  Select Case stability
  Case Is < -1.0
    ITC_TsTs = ABS(stability)^(-1.0/3.0)                    'Table 9.1 (Foken et al. 2004)

  Case Is <= -0.062 AND Is >= -1.0
    ITC_TsTs = ABS(stability)^(-0.25)                       'Table 9.1 (Foken et al. 2004)

  Case Is < 0.02 AND Is > -0.062
    ITC_TsTs = 0.5*ABS(stability)^(-0.50)                   'Table 9.1 (Foken et al. 2004)

  Case  Is >= 0.02 AND Is < 1.0
    ITC_TsTs = 1.4*stability^(-0.25)                        'Table 9.1 (Foken et al. 2004)

  Case Is >= 1.0
    ITC_TsTs = -(SIGMA_Ts/ABS(T_star))/9.1                    'Classify it into grade 9 when ZL >= 1
  EndSelect

  ITC_TsTs = ABS((ITC_TsTs - SIGMA_Ts/ABS(T_star))/ITC_TsTs)  'in fraction

  ITC_wTs = IIF ( (ITC_TsTs > ITC_ww), ITC_TsTs, ITC_ww)

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_wTs < 0.31)
  ITC_category(2) = (ITC_wTs < 0.31)
  ITC_category(3) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 0.76))
  ITC_category(4) = (ITC_wTs < 0.31)
  ITC_category(5) = ((ITC_wTs >= 0.31) AND (ITC_wTs < 1.01))
  ITC_category(6) = ((ITC_wTs >= 0.76) AND (ITC_wTs < 1.01))
  ITC_category(7) = ((ITC_wTs >= 1.01) AND (ITC_wTs < 2.51))
  ITC_category(8) = ((ITC_wTs >= 2.51) AND (ITC_wTs < 10.00))

  For J = 1 To 8
    ITC_Scalar_1st_Occur = -J *ITC_category(J)
    If (ITC_Scalar_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '1st case
  If  ((RNS_Scalar_1st_Occur = 0) OR (ITC_Scalar_1st_Occur =0)) Then        'Any in category 9 (0 used for 9, here)
    SSITC = 9

    '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 2, RNS_Scalar_1st_Occur)
    SSITC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_wTs = NaN)) AND (SSITC = 9)) Then  SSITC = NaN
EndSub
'*** End of subroutines for data quality classification ***


'*** Beginning of subroutines for Planetary Boundary-Layer Height ***
' Planetary Boundary-Layer height Kljun et al. (2004 2015)

'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  h_PBL                  PBLH                          Planetary Boundary-Layer height
'  Obukhov                MO_LENGTH

Sub Planetary_Boundary_Layer_Height(Obukhov, h_PBL)

  If (Obukhov <> NaN) Then
    'Estimate planetary boundary-layer (PBL) height using data in L- and h-columns in Table I in Kljun et al (2004)
    Select Case Obukhov
    Case Is < 0.0
      'h_PBL = 1000 m when Obukhov is -infinity. h_PBL = 1200 m at Obukhov = -650. Assume when Obukhov is <-650, h_PBL will decreases at the same rate
      'as h_PBL decreases when -650 < Obukhov <-30. Thus h_PBL reaches the limit of 1000 m at Obukhov = -1013.3; therefore, h_PBL = 1000 m if Obukhov <= -1013.3.
      If (Obukhov < -1013.3) Then
        h_PBL = 1000.0                                      'Set h_PBL = 1000 m as long as Obukhov < -1013.3 m.
      ElseIf (Obukhov <= -650) Then
        h_PBL = 1200.0 - 200.0*((Obukhov + 650.0)/(-1013.3+650.0))
      ElseIf (Obukhov <= -30.0) Then
        h_PBL = 1500.0 - 300.0*((Obukhov + 30.0)/(-650.0 + 30.0))
      ElseIf (Obukhov <= -5.0) Then
        h_PBL = 2000.0 - 500.0*((Obukhov + 5.0)/(-30.0 + 5.0))
      ElseIf (Obukhov <= 0.0) Then
        h_PBL = 2000.0 + 20.0*(Obukhov + 5.0)                  'Extrapolation to Obukhov --> -0.
      EndIf

    Case Is > 0.0
      'h_PBL = 1000 m when Obukhov is +infinity, and h_PBL = 800 m at Obukhov = 1000. Assume that h_PBL becomes higher with Obukhov at the same rate
      'as in the Obukhov range of 130 to 1000. Thus h_PBL reaches the limit of 1000 m at Obukhov = 1316.4; therefore, h_PBL = 1000 m if Obukhov > 1316.4
      If (Obukhov > 1316.4) Then
        h_PBL = 1000.0                                        'Set h_PBL = 1000 m as long as Obukhov > 1316.4 m.
      ElseIf (Obukhov >= 1000.0) Then
        h_PBL = 800.0 + 200.0*((Obukhov - 1000.0)/(1316.4-1000.0))
      ElseIf (Obukhov >= 130.0) Then
        h_PBL = 250.0 + 550.0*((Obukhov -130.0)/(1000.0 - 130.0))
      ElseIf (Obukhov >= 84.0) Then
        h_PBL = 200.0 + 50.0*((Obukhov - 84.0)/(130.0 -84.0))
      ElseIf (Obukhov > 0.0) Then
        h_PBL = 200.0 - (84.0 - Obukhov)*(50.0/46.0)               'Extrapolation to Obukhov --> +0
      EndIf
    EndSelect

  Else

    h_PBL = NaN

  EndIf

EndSub
'*** End of subroutines for Planetary Boundary-Layer Height ***

'*******************************************************************************************************************************************************************************
'*** MAIN PROGRAM ***'
'*********************'
BeginProg
  SW12 (1,1,1)


  ' *** Beginning to store and read station variables in CPU ***
  SemaphoreGet (1)
    stn_conf_array_file = FileOpen ("CPU:stn_conf_array.dat", "rb", 0)        'Open file and check if a file exists.
    stn_conf_array_file_size = FileSize (stn_conf_array_file)
    FileClose (stn_conf_array_file)
    #If  CSAT3B_B Then
      stnB_conf_array_file = FileOpen ("CPU:stnB_conf_array.dat", "rb", 0)        'Open file and check if a file exists.
      stnB_conf_array_file_size = FileSize (stnB_conf_array_file)
    #EndIf                                          'Close file after check
  SemaphoreRelease (1)

  If (stn_conf_array_file_size <> 4*NMBR_STN_VAR + 2) Then                  'Station configuration file does not exist.
    ' Set default values of station variables (Default values of 0 are listed for code readability although default value of variable is 0.)
    sonic_azimuth      = 64.0
    latitude           = clatitude        'Latitude o
    hemisphere_NS      = NORTH            '"1" for north and "-1" for south. e
    longitude          = clongitude         'Longitude
    hemisphere_EW      = EAST             '"1" for east and "-1" for west. e
    altitude           = caltitude        'Altitude
    height_measurement = 1.0
    surface_type       = ICE
    height_canopy      = 0.5
    displacement_user  = 0.0              '"0" indicates that the user DOES NOT have preferred zero displacement height
    roughness_user     = 0.0              '"0" indicates that the user DOES NOT have preferred roughness length

  Else

    Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:stn_conf_array.dat", 1)         'Read the stored values from the file.

  EndIf

  'Error control
  If ((sonic_azimuth < 0.0) OR (sonic_azimuth > 360.0)) Then
    sonic_azimuth = 0.0                  'Set back to default value
  EndIf

  If (ABS(latitude) > 90.0) Then
    latitude = 41.766                 'Set back to default value
  EndIf

  If ((hemisphere_NS <> NORTH) OR (hemisphere_NS <> SOUTH)) Then
    hemisphere_NS = NORTH
  EndIf

  If (ABS(longitude) > 180.0) Then
    longitude = -111.855              'Set back to default value
  EndIf

  If ((hemisphere_EW <> EAST) OR (hemisphere_EW <> WEST)) Then
    hemisphere_EW = WEST              'Set back to default value
  EndIf

  If ((altitude > 8000.0) OR (altitude < -1000.0)) Then
    altitude = 1356.0                 'Set back to default value
  EndIf

  If ((height_measurement > 450.0) OR (height_measurement < 0.2)) Then
    height_measurement = 2.0          'Set back to default value
  EndIf

  If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND (height_measurement > 100.0)) Then
    height_measurement = 2.0            'Set back to default value
  EndIf

  If ((surface_type < CROP) OR (surface_type > ICE)) Then
    surface_type = GRASS                'Set back to default value
  EndIf

  If ((surface_type = BARELAND) OR (surface_type = WATER) OR (surface_type = ICE)) Then
    height_canopy = 0.0                 'Set back to default value
  EndIf

  If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND (height_canopy > 15.0)) Then
    height_canopy = 0.5                 'Set back to default value
  EndIf

  If ((surface_type = FOREST) OR (height_canopy > 100.0)) Then
    height_canopy = 0.5                 'Set back to default value
  EndIf

  If (displacement_user > height_measurement) OR (displacement_user < 0.0) Then
    displacement_user = 0.0            'Set back to default value
  EndIf

  If (roughness_user > height_measurement) OR (roughness_user < 0.0) Then
    roughness_user = 0.0               'Set back to default value
  EndIf

  #If CSAT3B_B Then
    If (stnB_conf_array_file_size <> 4*NMBR_STN_VAR + 2) Then                  'Station configuration file does not exist.
      ' Set default values of station variables (Default values of 0 are listed for code readability although default value of variable is 0.)
      sonic_azimuthB      = 64.0
      latitudeB           = clatitude           'Latitude
      hemisphere_NSB      = NORTH            '"1" for north and "-1" for south. e
      longitudeB          = clongitude        'Longitude o
      hemisphere_EWB      = EAST             '"1" for east and "-1" for west.
      altitudeB           = caltitude           'Altitude
      height_measurementB = 2.8
      surface_typeB       = ICE
      height_canopyB      = 0.5
      displacement_userB  = 0.0              '"0" indicates that the user DOES NOT have preferred zero displacement height
      roughness_userB     = 0.0              '"0" indicates that the user DOES NOT have preferred roughness length

    Else

      Calfile (stnB_conf_array(1), NMBR_STN_VAR, "CPU:stnB_conf_array.dat", 1)         'Read the stored values from the file.

    EndIf

    'Error control
    If ((sonic_azimuthB < 0.0) OR (sonic_azimuthB > 360.0)) Then
      sonic_azimuthB = 0.0                  'Set back to default value
    EndIf

    If (ABS(latitudeB) > 90.0) Then
      latitudeB = 41.766                 'Set back to default value
    EndIf

    If ((hemisphere_NSB <> NORTH) OR (hemisphere_NSB <> SOUTH)) Then
      hemisphere_NSB = NORTH
    EndIf

    If (ABS(longitudeB) > 180.0) Then
      longitudeB = -111.855              'Set back to default value
    EndIf

    If ((hemisphere_EWB <> EAST) OR (hemisphere_EWB <> WEST)) Then
      hemisphere_EWB = WEST              'Set back to default value
    EndIf

    If ((altitudeB > 8000.0) OR (altitudeB < -1000.0)) Then
      altitudeB = 1356.0                 'Set back to default value
    EndIf

    If ((height_measurementB > 450.0) OR (height_measurementB < 0.2)) Then
      height_measurementB = 4.0          'Set back to default value
    EndIf

    If (((surface_typeB = CROP) OR (surface_typeB = GRASS) OR (surface_typeB = SHRUB)) AND (height_measurementB > 100.0)) Then
      height_measurementB = 4.0            'Set back to default value
    EndIf

    If ((surface_typeB < CROP) OR (surface_typeB > ICE)) Then
      surface_typeB = GRASS                'Set back to default value
    EndIf

    If ((surface_typeB = BARELAND) OR (surface_typeB = WATER) OR (surface_typeB = ICE)) Then
      height_canopyB = 0.0                 'Set back to default value
    EndIf

    If (((surface_typeB = CROP) OR (surface_typeB = GRASS) OR (surface_typeB = SHRUB)) AND (height_canopyB > 15.0)) Then
      height_canopyB = 0.5                 'Set back to default value
    EndIf

    If ((surface_typeB = FOREST) OR (height_canopyB > 100.0)) Then
      height_canopyB = 0.5                 'Set back to default value
    EndIf

    If (displacement_userB > height_measurementB) OR (displacement_userB < 0.0) Then
      displacement_userB = 0.0            'Set back to default value
    EndIf

    If (roughness_userB > height_measurementB) OR (roughness_userB < 0.0) Then
      roughness_userB = 0.0               'Set back to default value
    EndIf
  #EndIf


  '*** Beginning to calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan ***
  Call Displacement_roughness_heights (surface_type, displacement_user, roughness_user, height_canopy, height_measurement, d, z0, z)
  '*** End of calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan ***

  For i = 14 To 17
    If  (NOT (stn_conf_array(i) > 0.0)) Then
      stn_conf_array(i) = 100.0*z                                               'Default value of 100*z for all sectors in different directions
    EndIf
  Next

  z_prev = z
  Move(stn_conf_array_prev(1), NMBR_STN_VAR , stn_conf_array(1), NMBR_STN_VAR)   'Keep current values of stn_conf_array() in stn_conf_array_prev() for later reference as previous values
  surface_type_text = surface_type_array(surface_type)

  Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:stn_conf_array.dat", 0)         'Store the values to the file.
  ' *** End to store and read station variables in CPU ***

  #If CSAT3B_B Then

    '*** Beginning to calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan ***
    Call Displacement_roughness_heights (surface_typeB, displacement_userB, roughness_userB, height_canopyB, height_measurementB, dB, z0B, zB)
    '*** End of calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan ***

    For i = 14 To 17
      If  (NOT (stnB_conf_array(i) > 0.0)) Then
        stnB_conf_array(i) = 100.0*zB                                               'Default value of 100*z for all sectors in different directions
      EndIf
    Next

    zB_prev = zB
    Move(stnB_conf_array_prev(1), NMBR_STN_VAR , stnB_conf_array(1), NMBR_STN_VAR)   'Keep current values of stn_conf_array() in stn_conf_array_prev() for later reference as previous values
    surface_type_text = surface_type_array(surface_typeB)

    Calfile (stnB_conf_array(1), NMBR_STN_VAR, "CPU:stnB_conf_array.dat", 0)         'Store the values to the file.
    ' *** End to store and read station variables in CPU ***
  #EndIf

  Planar_Fit_flg = FALSE

  'Beginning time stamp NU in this version
  CR6_clock = status.timestamp(4,1)
  TIMESTAMP_START = Left (CR6_clock, 4) & Mid (CR6_clock, 6, 2) & Mid (CR6_clock, 9, 2) & Mid (CR6_clock,12,2)& Mid (CR6_clock,15,2)
  TIMESTAMP_START = Left (TIMESTAMP_START, 12)
  Erase(TIMESTAMP_END)

  '*** Check how many days left for data storage in MicroSD ****
  card_bytes_free = Status.CardBytesFree                                   'In bytes.

  If  (card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") Then
    card_bytes_free_unassgnd = card_bytes_free

    '*** Compute the DataTable size for time series
    '16 bytes for TimeStamp and record number, 4 bytes for each variable in IEEE4 and Long
    bytes_rcd_Time_Series =  (16 + 5 * 4 )
    '24 hours/day, 3600 seconds/hour, (1000/SCN_INTV) is scan rate in Hz, "1.1" is factor used in CR6 OS, and "1000" is a unit conversion factor from bytes to KB.
    bytes_tbl_Time_Series = (DAY_TSRS_CRD*24*3600*(1000/SCN_INTV)*1.1)*bytes_rcd_Time_Series

    'Add the bytes in KB for row heading and extra
    bytes_tbl_Time_Series = ( 1 - CSAT3B_B ) * (bytes_tbl_Time_Series + 1024*3.13)  ' BYTES PER FILE(s) TIME SERIES

    day_snc_0101_1990 = SecsSince1990(status.TimeStamp(1,1), 1)/(24*3600)
    days_actv_tbl_Time_Series = DAY_TSRS_CRD - (day_snc_0101_1990 MOD DAY_TSRS_CRD)  ' REMAINING DAYS TO BE STORED IN ONE FILE FOR TIMESERIES
    'Pre-set, assume no extra storage in MicroSD
    days_totl_tbl_Time_Series = days_actv_tbl_Time_Series

    '*** Campute the Table size for flux table in CSFormat
    '16 bytes for TimeStamp and record number, 4 bytes for each variable in IEEE4 or Long,
    '60 uncoditial variables, and 16 bytes for one string variable (i.e. FP_EQUATION)
    bytes_rcd_flux_CSFormat = 16 + 4*60 + 16*1 + 16*2

    '*** Campute the Table size for flux note portion
    '16 bytes for TimeStamp and record number (added according to ONE_FL_TABLE), 4 bytes for each variable in IEEE4 or Long, and 118 uncoditial variables,
    x_tmp = 4*75
    '16 bytes added for TimeStemp and record number
    bytes_rcd_flux_notes = 16 + x_tmp
    '24 hours/day, 60 minutes/hour, factor 1.1 used in CR6 OS, and 5 KB for row heading and extra (approximation)
    bytes_tbl_flux_notes = ( 1 - CSAT3B_B ) * (DAY_FLUX_CRD*(24*60/OUTPUT_INTV)*1.1*bytes_rcd_flux_notes + 1024*5.0) 'BYTES PER FILE(s) FLUX NOTES

    days_actv_tbl_flux_CSFormat_notes = DAY_FLUX_CRD - (day_snc_0101_1990 MOD DAY_FLUX_CRD)

    'Pre-set, assume no extra storage in MicroSD
    days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes

    'Flux_AmeriFluxFormat is not pre-allocated, but used the same DAY_FLUX_CRD as Flux_CSFormat and Flux_notes ues.
    'The bytes used within days_actv_tbl_flux_CSFormat are included in card_bytes_free, which should be considered as assigned bytes.
    'card_bytes_free_assgnd = (days_actv_tbl_flux_CSFormat_notes/DAY_FLUX_CRD)*bytes_tbl_AmeriFluxFormat

    '24 hours/day, 60 minutes/hour, factor 1.1 used in CR6 OS, and 5KB for row heading and extra (approximation)
    bytes_tbl_flux_CSFormat  = ( 1 - CSAT3B_B ) * (DAY_FLUX_CRD*(24*60/OUTPUT_INTV)*1.1*bytes_rcd_flux_CSFormat + 1025*5.0)  ' BYTES PER FILE(s) FLUX CSI format

    card_bytes_free_unassgnd = card_bytes_free - card_bytes_free_assgnd            'BYTE FREE AND UNASSIGND ON CARD

    While (((days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) AND (card_bytes_free_unassgnd > bytes_tbl_Time_Series)) OR  ((days_totl_tbl_flux_CSFormat_notes < days_totl_tbl_Time_Series)  AND (card_bytes_free_unassgnd > (bytes_tbl_flux_CSFormat + bytes_tbl_flux_notes))))

      If (days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) Then
        card_bytes_free_assgnd    = card_bytes_free_assgnd    + bytes_tbl_Time_Series
        days_more_tbl_Time_Series = days_more_tbl_Time_Series + DAY_TSRS_CRD
        days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series

      Else
        card_bytes_free_assgnd            = card_bytes_free_assgnd + bytes_tbl_flux_CSFormat + bytes_tbl_flux_notes
        days_more_tbl_flux_CSFormat_notes = days_more_tbl_flux_CSFormat_notes + DAY_FLUX_CRD
        days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes

      EndIf

      card_bytes_free_unassgnd  = card_bytes_free - card_bytes_free_assgnd

    Wend

    If (days_totl_tbl_Time_Series >= days_totl_tbl_flux_CSFormat_notes) Then
      card_storage_available_days = days_totl_tbl_flux_CSFormat_notes
    Else
      card_storage_available_days = days_totl_tbl_Time_Series
    EndIf


  Else
    days_actv_tbl_Time_Series          = NaN
    days_more_tbl_Time_Series          = NaN
    days_totl_tbl_Time_Series          = NaN

    days_actv_tbl_flux_CSFormat_notes = NaN
    days_more_tbl_flux_CSFormat_notes = NaN
    days_totl_tbl_flux_CSFormat_notes = NaN

    card_storage_available_days       = NaN

  EndIf '(card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.")

  '*** End of Checking how many days left for data storage in MicroSD ****

  ' Read date and time from CR6 for soil heat flux and for estimation of days available for data storage in MicroSD
  RealTime(realtime_array(1))
  If NOT flaginit Then Call init

  ' Add CDM-A116 as a CPI module
  CPIAddModule (CDM_A116, CDM_SN, CPI_DEVICE, CPI_ADDR_CDM)


  '*************************** SCAN LOOP  **************************************************
  Scan (SCN_INTV, mSec, SCAN_BUFFER_SIZE, 0)

    '*** Beginning of CSI CSAT measurements ***

    'Get CSAT3B data

    CSAT3B (sonic_raw(1),1,10,0)      '1st to 5th elements: Sonic data
    CallTable delay_3d

    #If  CSAT3B_B Then                'Sonic data: Ux, Uy, Uz, Ts, and diag_sonic
      CSAT3B (sonicB_raw(1),1,11,0)   '1st to 5th elements: Sonic data
      CallTable delay_3dB
    #EndIf

    '*** End of CSAT measurements ***

    'PulsCount Instructions are placed here after all fast sensors finish their measurements because PulseCount() is not allowed in any conditional statements.
    #If SENSOR_WFlow Then
      PulseCount (WaterFlow,1,C2,1,SLW_SCN_INTV,0.06,0)
    #EndIf

    If scan_count >= 1 Then

      '*** Beginning of CSAT sonic head processing ***
      'Load in CSAT sonic head data
      GetRecord (dly_data_out(1),delay_3d,1)

      Ts = dly_data_out(4)                               'sonic(1): Ts
      Move (Ux, 3, dly_data_out(1), 3)                   'sonic(2), sonic(3), sonic(4) : Ux, Uy, Uz
      diag_sonic = dly_data_out(5)                       'sonic(5): diag_sonic

      U_rslt = SQR(Ux*Ux + Uy*Uy + Uz*Uz)

      'Extract the six warning flags from the sonic diagnostic word
      diag_sonic_tmp = IIF ((diag_sonic <> NAN) AND (diag_sonic <> -1), diag_sonic, &h3f)
      diag_sonic_aggregate = diag_sonic_aggregate OR diag_sonic_tmp
      mask = &h1
      For i = 1 To 6
        diag_bits_sonic(i) = diag_sonic_tmp AND mask
        mask = mask*2
      Next i

      'Turn on the intermediate processing disable flag when any CSAT sonic head warning flag is high.
      sonic_disable_f = (diag_sonic_tmp <> 0)

      Ts_K = Ts + T_0C_K

      'Call Table for 5-minute and 30-minute table
      CallTable comp_cov_3d_5min                                                             'for Steady State Test
      CallTable comp_cov_3d                                                                  'for half-hourly data

      #If CSAT3B_B Then
        '*** Beginning of CSAT sonic head processing ***
        'Load in CSAT sonic head data
        GetRecord (dly_data_outB(1),delay_3dB,1)

        TBs = dly_data_outB(4)                               'sonic(1): Ts
        Move (UBx, 3, dly_data_outB(1), 3)                   'sonic(2), sonic(3), sonic(4) : Ux, Uy, Uz
        diag_sonicB = dly_data_outB(5)                       'sonic(5): diag_sonic

        UB_rslt = SQR(UBx*UBx + UBy*UBy + UBz*UBz)

        'Extract the six warning flags from the sonic diagnostic word
        diag_sonicB_tmp = IIF ((diag_sonicB <> NAN) AND (diag_sonicB <> -1), diag_sonicB, &h3f)
        diag_sonicB_aggregate = diag_sonicB_aggregate OR diag_sonicB_tmp
        mask = &h1
        For i = 1 To 6
          diag_bits_sonicB(i) = diag_sonicB_tmp AND mask
          mask = mask*2
        Next i

        'Turn on the intermediate processing disable flag when any CSAT sonic head warning flag is high.
        sonicB_disable_f = (diag_sonic_tmp <> 0)

        TBs_K = TBs + T_0C_K

        'Call Table for 5-minute and 30-minute table
        CallTable comp_covB_3d_5min                                                             'for Steady State Test
        CallTable comp_covB_3d
      #EndIf

      ' The data for Steady State Test (SST)
      If (comp_cov_3d_5min.Output(1, 1)) Then
        GetRecord (Ux_Avg_SST, comp_cov_3d_5min, 1)

        'Double coordinate rotations
        gamma_5min = WD_SONIC_SST                                                          'Rotation angle about z-axis
        alpha_5min = -ATN2(Uz_Avg_SST, SQR(Ux_Avg_SST*Ux_Avg_SST + Uy_Avg_SST*Uy_Avg_SST)) 'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

        ' Rotation for momentum variables
        Call Rotation12_Momentum(alpha_5min, gamma_5min,Ux_Avg_SST, Uy_Avg_SST, Uz_Avg_SST, Ux_Var_SST, Uy_Var_SST, Uz_Var_SST, UxUy_Cov_SST, UxUz_Cov_SST, UyUz_Cov_SST,U_SST,V_SST,W_SST,U_Var_SST,V_Var_SST,W_Var_SST,UV_Cov_SST,UW_Cov_SST,VW_Cov_SST)
        'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W

        'Rotation for the covariance of sonic temperature with velocities
        Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min,TsUx_Cov_SST,TsUy_Cov_SST,TsUz_Cov_SST,UT_SONIC_Cov_SST, VT_SONIC_Cov_SST, WT_SONIC_Cov_SST)
        'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC

        ' Rotations for momentum variables
        Call Rotation23_Momentum(alpha_5min, beta_5min,Ux_Avg_SST, Uy_Avg_SST, Uz_Avg_SST, Ux_Var_SST, Uy_Var_SST, Uz_Var_SST, UxUy_Cov_SST, UxUz_Cov_SST, UyUz_Cov_SST,U_SST,V_SST,W_SST,U_Var_SST,V_Var_SST,W_Var_SST,UV_Cov_SST,UW_Cov_SST,VW_Cov_SST)
        'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W

        'Rotations for the covariance of sonic temperature with velocities
        Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min,TsUx_Cov_SST,TsUy_Cov_SST,TsUz_Cov_SST,UT_SONIC_Cov_SST, VT_SONIC_Cov_SST, WT_SONIC_Cov_SST)
        'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC

        If ((UW_Cov_SST <> NaN) AND (VW_Cov_SST <> NaN) AND (WT_SONIC_Cov_SST <> NaN)) Then
          RN_UW_cov       += UW_Cov_SST
          RN_VW_cov       += VW_Cov_SST
          RN_WT_SONIC_cov += WT_SONIC_Cov_SST

          nmbr_interval_qc_csat += 1
        EndIf
      EndIf

      #If CSAT3B_B Then

        ' The data for Steady State Test (SST)
        If (comp_covB_3d_5min.Output(1, 1)) Then
          GetRecord (UBx_Avg_SST, comp_covB_3d_5min, 1)

          'Double coordinate rotations
          gammaB_5min = WDB_SONIC_SST                                                          'Rotation angle about z-axis
          alphaB_5min = -ATN2(UBz_Avg_SST, SQR(UBx_Avg_SST*UBx_Avg_SST + UBy_Avg_SST*UBy_Avg_SST)) 'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

          ' Rotation for momentum variables
          Call Rotation12_Momentum(alphaB_5min, gammaB_5min,UBx_Avg_SST, UBy_Avg_SST, UBz_Avg_SST, UBx_Var_SST, UBy_Var_SST, UBz_Var_SST, UxUyB_Cov_SST, UxUzB_Cov_SST, UyUzB_Cov_SST, UB_SST,VB_SST,WB_SST,UB_Var_SST,VB_Var_SST,WB_Var_SST,UVB_Cov_SST,UWB_Cov_SST,VWB_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W

          'Rotation for the covariance of sonic temperature with velocities
          Call Rotation12_Scalar_Covariance(alphaB_5min, gammaB_5min,TsUxB_Cov_SST,TsUyB_Cov_SST,TsUzB_Cov_SST,UTB_SONIC_Cov_SST,VTB_SONIC_Cov_SST,WTB_SONIC_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC

          ' Rotations for momentum variables
          Call Rotation23_Momentum(alphaB_5min, betaB_5min, UBx_Avg_SST, UBy_Avg_SST, UBz_Avg_SST, UBx_Var_SST, UBy_Var_SST, UBz_Var_SST, UxUyB_Cov_SST, UxUzB_Cov_SST, UyUzB_Cov_SST,UB_SST,VB_SST,WB_SST,UB_Var_SST,VB_Var_SST,WB_Var_SST,UVB_Cov_SST,UWB_Cov_SST,VWB_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W

          'Rotations for the covariance of sonic temperature with velocities
          Call Rotation23_Scalar_Covariance(alphaB_5min, betaB_5min,TsUxB_Cov_SST,TsUyB_Cov_SST,TsUzB_Cov_SST,UTB_SONIC_Cov_SST,VTB_SONIC_Cov_SST,WTB_SONIC_Cov_SST)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC


          If ((UWB_Cov_SST <> NaN) AND (VWB_Cov_SST <> NaN) AND (WTB_SONIC_Cov_SST <> NaN)) Then
            RN_UWB_cov       += UWB_Cov_SST
            RN_VWB_cov       += VWB_Cov_SST
            RN_WTB_SONIC_cov += WTB_SONIC_Cov_SST
            nmbr_interval_qc_csatB += 1
          EndIf
        EndIf

      #EndIf

      If (comp_cov_3d.Output(1, 1) AND comp_cov_3d_5min.Output(1, 1))Then
        GetRecord (Ux_Avg, comp_cov_3d, 1)                                'Ux_avg is the 1st element of cov_out_sonic
        T_SONIC       = Ts_Avg                                            'For output in AmeriFlux format
        Ts_SIGMA      = SQR(Ts_SIGMA)
        T_SONIC_SIGMA = Ts_SIGMA

        '*** Coordinate rotations ***

        'Double coordinate rotations
        gamma = WD_SONIC                                                'Rotation angle about z-axis
        alpha = -ATN2(Uz_Avg, SQR(Ux_Avg*Ux_Avg + Uy_Avg*Uy_Avg))       'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

        ' Rotation for momentum variables
        Call Rotation12_Momentum(alpha, gamma,           Ux_Avg, Uy_Avg, Uz_Avg, Ux_SIGMA, Uy_SIGMA, Uz_SIGMA, UxUy_Cov, UxUz_Cov, UyUz_Cov,           U,      V,      W,      U_SIGMA,  V_SIGMA,  W_SIGMA,  UV_Cov,   UW_Cov,   VW_Cov)
        'After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W.

        'Rotation for the covariance of sonic temperature with velocities
        Call Rotation12_Scalar_Covariance(alpha, gamma,           TsUx_Cov,     TsUy_Cov,     TsUz_Cov,           UT_SONIC_Cov, VT_SONIC_Cov, WT_SONIC_Cov)
        'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC


        ' Rotations for momentum variables
        Call Rotation23_Momentum(alpha, beta,           Ux_Avg, Uy_Avg, Uz_Avg, Ux_SIGMA, Uy_SIGMA, Uz_SIGMA, UxUy_Cov, UxUz_Cov, UyUz_Cov,           U,      V,      W,      U_SIGMA,  V_SIGMA,  W_SIGMA,  UV_Cov,   UW_Cov,   VW_Cov)
        'After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W.

        'Rotations for the covariance of sonic temperature with velocities
        Call Rotation23_Scalar_Covariance(alpha, beta,           TsUx_Cov,     TsUy_Cov,     TsUz_Cov,           UT_SONIC_Cov, VT_SONIC_Cov, WT_SONIC_Cov)
        'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC
      EndIf

      'After coordinate rotation, variables ending with _SIGMA are actually variances but later the square root will be taken to give standard deviation.
      Ux_SIGMA = SQR(Ux_SIGMA)
      Uy_SIGMA = SQR(Uy_SIGMA)
      Uz_SIGMA = SQR(Uz_SIGMA)

      '*** End of coordinate rotations ***

      'Rotate the CSAT sonic head RHC system so the negative x-axis points north
      WD = (360.0 + sonic_azimuth - WD_SONIC) MOD 360

      'Compute specific turbulence kinetic energy
      TKE = 0.5*(U_SIGMA + V_SIGMA + W_SIGMA)

      'Compute the standard deviation from the variance after rotation
      U_SIGMA = SQR (U_SIGMA)
      V_SIGMA = SQR (V_SIGMA)
      W_SIGMA = SQR (W_SIGMA)

      '*** Freq corrections for UW_Cov, VW_Cov, and WT_SONIC_Cov ***
      'Compute online fluxes after rotations (preliminary).
      USTAR_R =  SQR(SQR((UW_Cov*UW_Cov) + (VW_Cov*VW_Cov)))

      ' Preparation for freq correction to UW_Cov, VW_Cov, and WT_SONIC_cov
      ' Monin-Obukhov length (preliminary)
      MO_LENGTH = -USTAR_R*USTAR_R*USTAR_R*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov)

      ' Atmospheric boundary-layer stability (preliminary)
      ZL = z/MO_LENGTH

      FreqFactor_UW_VW_Prev = 1 - 2*ACCURACY_FREQ_FACTOR
      Call  FreqFactorCSAT_uw_vw_BA_LA(z, ZL, WS_RSLT, FreqFactor_UW_VW)

      UW_Cov_fc = FreqFactor_UW_VW * UW_Cov
      VW_Cov_fc = FreqFactor_UW_VW * VW_Cov
      USTAR = SQR(SQR ((UW_Cov_fc*UW_Cov_fc) + (VW_Cov_fc*VW_Cov_fc)))

      FreqFactor_WT_SONIC_Prev = 1 - 2*ACCURACY_FREQ_FACTOR
      Call  FreqFactorCSAT_wTs_BA_LA (z, ZL, WS_RSLT, tran_func_LA_data_Dijk(1,1), FreqFactor_WT_SONIC)

      WT_SONIC_Cov_fc = FreqFactor_WT_SONIC * WT_SONIC_Cov

      ' Recalculate Monin-Obukhov length
      MO_LENGTH = -USTAR*USTAR*USTAR*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov_fc)

      ' Recalculate atmospheric boundary-layer stability
      ZL_prev = ZL
      ZL      = z/MO_LENGTH

      iteration_FreqFactor = 1
      While (((ABS (FreqFactor_UW_VW_Prev -FreqFactor_UW_VW) >= ACCURACY_FREQ_FACTOR) OR           (ABS (FreqFactor_WT_SONIC_Prev - FreqFactor_WT_SONIC) >= ACCURACY_FREQ_FACTOR)) AND ((ZL > 0.0) AND (iteration_FreqFactor <= 10)))

        ZL_prev                  = ZL
        FreqFactor_UW_VW_Prev    = FreqFactor_UW_VW
        FreqFactor_WT_SONIC_Prev = FreqFactor_WT_SONIC

        Call  FreqFactorCSAT_uw_vw_BA_LA (z, ZL, WS_RSLT, FreqFactor_UW_VW)
        UW_Cov_fc = FreqFactor_UW_VW * UW_Cov
        VW_Cov_fc = FreqFactor_UW_VW * VW_Cov
        USTAR = SQR(SQR (UW_Cov_fc*UW_Cov_fc + VW_Cov_fc*VW_Cov_fc))

        Call  FreqFactorCSAT_wTs_BA_LA (z, ZL, WS_RSLT, tran_func_LA_data_Dijk(1,1), FreqFactor_WT_SONIC)
        WT_SONIC_Cov_fc = FreqFactor_WT_SONIC * WT_SONIC_Cov

        ' Monin-Obukhov length
        MO_LENGTH = -USTAR*USTAR*USTAR*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov_fc)

        ' Atmospheric boundary-layer stability
        ZL = z/MO_LENGTH

        iteration_FreqFactor += 1
      Wend
      '*** End of freq corrections for UW_Cov, VW_Cov, and wT_SONIC_cov ***

      '*** Beginning of data quality classification for momentum flux ***
      'Calculate the measures of relative non-stationarity (Steady State Test)
      RN_UW_VW_cov = ABS(((RN_UW_cov + RN_VW_cov)/nmbr_interval_qc_csat - UW_Cov - VW_Cov)/(UW_Cov + VW_Cov))  'in fraction
      RN_UW_cov = 0
      RN_VW_cov = 0

      Call Data_Quality_SSITC_w_WndDir_Momentum  (Planar_Fit_flg, ZL, U_SIGMA, W_SIGMA, USTAR, latitude, WD_SONIC, RN_UW_VW_cov, TAU_QC)
      Call Data_Quality_SSITC_wo_WndDir_Momentum (Planar_Fit_flg, ZL, U_SIGMA, W_SIGMA, USTAR, latitude,           RN_UW_VW_cov, TAU_SSITC_TEST)
      '*** End of data quality classification for momentum flux ***
      '*** Data quality classification for scalar fluxes ***
      'Sensible heat flux
      'Calculate the measures of relative non-stationarity (Steady State Test)
      RN_WT_SONIC_cov  = ABS((RN_WT_SONIC_cov/nmbr_interval_qc_csat - WT_SONIC_Cov)/WT_SONIC_Cov)                                              'in fraction
      Call Data_Quality_SSITC_w_WndDir_Scalar  (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude, WD_SONIC, RN_WT_SONIC_cov, H_QC)           'Quality classification for sensible heat flux w/ considering wind direction
      Call Data_Quality_SSITC_wo_WndDir_Scalar (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude,           RN_WT_SONIC_cov, H_SSITC_TEST)   'Quality classification for sensible heat flux w/o considering wind direction
      RN_WT_SONIC_cov = 0.0
      nmbr_interval_qc_csat = 0.0

      'Calculate planetary boundary layer height
      Call Planetary_Boundary_Layer_Height(MO_LENGTH, PBLH)

      #If CSAT3B_B Then

        If (comp_covB_3d.Output(1, 1) AND comp_covB_3d_5min.Output(1, 1))Then
          GetRecord (UBx_Avg, comp_covB_3d, 1)                                'Ux_avg is the 1st element of cov_out_sonic
          TB_SONIC       = TBs_Avg                                            'For output in AmeriFlux format
          TBs_SIGMA      = SQR(TBs_SIGMA)
          TB_SONIC_SIGMA = TBs_SIGMA

          '*** Coordinate rotations ***

          'Double coordinate rotations
          gammaB = WDB_SONIC                                                'Rotation angle about z-axis
          alphaB = -ATN2(UBz_Avg, SQR(UBx_Avg*UBx_Avg + UBy_Avg*UBy_Avg))       'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

          ' Rotation for momentum variables
          Call Rotation12_Momentum(alphaB, gammaB,UBx_Avg, UBy_Avg, UBz_Avg, UBx_SIGMA, UBy_SIGMA, UBz_SIGMA, UxUyB_Cov, UxUzB_Cov, UyUzB_Cov,UB,VB,WB,UB_SIGMA,VB_SIGMA,WB_SIGMA,UVB_Cov,UWB_Cov,VWB_Cov)
          'After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W.

          'Rotation for the covariance of sonic temperature with velocities
          Call Rotation12_Scalar_Covariance(alphaB, gammaB,TsUxB_Cov,TsUyB_Cov,TsUzB_Cov,UTB_SONIC_Cov, VTB_SONIC_Cov, WTB_SONIC_Cov)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC


          ' Rotations for momentum variables
          Call Rotation23_Momentum(alphaB, betaB,UBx_Avg, UBy_Avg, UBz_Avg, UBx_SIGMA, UBy_SIGMA, UBz_SIGMA, UxUyB_Cov, UxUzB_Cov, UyUzB_Cov,UB,VB,WB, UB_SIGMA,VB_SIGMA,WB_SIGMA,UVB_Cov,UWB_Cov,VWB_Cov)
          'After coordinate rotations, Ux is denoted by U, Uy by V, and Uz by W.

          'Rotations for the covariance of sonic temperature with velocities
          Call Rotation23_Scalar_Covariance(alphaB, betaB,TsUxB_Cov,TsUyB_Cov,TsUzB_Cov,UTB_SONIC_Cov,VTB_SONIC_Cov,WTB_SONIC_Cov)
          'Note: After coordinate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC
        EndIf

        'After coordinate rotation, variables ending with _SIGMA are actually variances but later the square root will be taken to give standard deviation.
        UBx_SIGMA = SQR(UBx_SIGMA)
        UBy_SIGMA = SQR(UBy_SIGMA)
        UBz_SIGMA = SQR(UBz_SIGMA)

        '*** End of coordinate rotations ***

        'Rotate the CSAT sonic head RHC system so the negative x-axis points north
        WDB = (360.0 + sonic_azimuthB - WDB_SONIC) MOD 360

        'Compute specific turbulence kinetic energy
        TKEB = 0.5*(UB_SIGMA + VB_SIGMA + WB_SIGMA)

        'Compute the standard deviation from the variance after rotation
        UB_SIGMA = SQR (UB_SIGMA)
        VB_SIGMA = SQR (VB_SIGMA)
        WB_SIGMA = SQR (WB_SIGMA)

        '*** Freq corrections for UW_Cov, VW_Cov, and WT_SONIC_Cov ***
        'Compute online fluxes after rotations (preliminary).
        USTARB_R =  SQR(SQR((UWB_Cov*UWB_Cov) + (VWB_Cov*VWB_Cov)))

        ' Preparation for freq correction to UW_Cov, VW_Cov, and WT_SONIC_cov
        ' Monin-Obukhov length (preliminary)
        MO_LENGTHB = -USTARB_R*USTARB_R*USTARB_R*(TB_SONIC + T_0C_K)/(k*g0*WTB_SONIC_Cov)

        ' Atmospheric boundary-layer stability (preliminary)  191919!!!!
        ZLB = zB/MO_LENGTHB

        FreqFactorB_UW_VW_Prev = 1 - 2*ACCURACY_FREQ_FACTOR
        Call  FreqFactorCSAT_uw_vw_BA_LA(zB, ZLB, WSB_RSLT, FreqFactorB_UW_VW)

        UWB_Cov_fc = FreqFactorB_UW_VW * UWB_Cov
        VWB_Cov_fc = FreqFactorB_UW_VW * VWB_Cov
        USTARB = SQR(SQR ((UWB_Cov_fc*UWB_Cov_fc) + (VWB_Cov_fc*VWB_Cov_fc)))

        FreqFactorB_WT_SONIC_Prev = 1 - 2*ACCURACY_FREQ_FACTOR
        Call  FreqFactorCSAT_wTs_BA_LA (zB, ZLB, WSB_RSLT, tran_func_LA_data_Dijk(1,1), FreqFactorB_WT_SONIC)

        WTB_SONIC_Cov_fc = FreqFactorB_WT_SONIC * WTB_SONIC_Cov

        ' Recalculate Monin-Obukhov length
        MO_LENGTHB = -USTARB*USTARB*USTARB*(TB_SONIC + T_0C_K)/(k*g0*WTB_SONIC_Cov_fc)

        ' Recalculate atmospheric boundary-layer stability
        ZLB_prev = ZLB
        ZLB      = zB/MO_LENGTHB

        iteration_FreqFactorB = 1
        While (((ABS (FreqFactorB_UW_VW_Prev -FreqFactorB_UW_VW) >= ACCURACY_FREQ_FACTOR) OR (ABS (FreqFactorB_WT_SONIC_Prev - FreqFactorB_WT_SONIC) >= ACCURACY_FREQ_FACTOR)) AND ((ZLB > 0.0) AND (iteration_FreqFactorB <= 10)))
          ZLB_prev                  = ZLB
          FreqFactorB_UW_VW_Prev    = FreqFactorB_UW_VW
          FreqFactorB_WT_SONIC_Prev = FreqFactorB_WT_SONIC

          Call  FreqFactorCSAT_uw_vw_BA_LA (zB, ZLB, WSB_RSLT, FreqFactorB_UW_VW)
          UWB_Cov_fc = FreqFactorB_UW_VW * UWB_Cov
          VWB_Cov_fc = FreqFactorB_UW_VW * VWB_Cov
          USTARB = SQR(SQR (UWB_Cov_fc*UWB_Cov_fc + VWB_Cov_fc*VWB_Cov_fc))

          Call  FreqFactorCSAT_wTs_BA_LA (zB, ZLB, WSB_RSLT, tran_func_LA_data_Dijk(1,1), FreqFactorB_WT_SONIC)
          WTB_SONIC_Cov_fc = FreqFactorB_WT_SONIC * WTB_SONIC_Cov

          ' Monin-Obukhov length
          MO_LENGTHB = -USTARB*USTARB*USTARB*(TB_SONIC + T_0C_K)/(k*g0*WTB_SONIC_Cov_fc)

          ' Atmospheric boundary-layer stability
          ZLB = zB/MO_LENGTHB

          iteration_FreqFactorB += 1
        Wend
        '*** End of freq corrections for UW_Cov, VW_Cov, and wT_SONIC_cov ***

        '*** Beginning of data quality classification for momentum flux ***
        'Calculate the measures of relative non-stationarity (Steady State Test)
        RN_UW_VWB_cov = ABS(((RN_UWB_cov + RN_VWB_cov)/nmbr_interval_qc_csatB - UWB_Cov - VWB_Cov)/(UWB_Cov + VWB_Cov))  'in fraction
        RN_UWB_cov = 0
        RN_VWB_cov = 0

        Call Data_Quality_SSITC_w_WndDir_Momentum  (Planar_Fit_flg, ZLB, UB_SIGMA, WB_SIGMA, USTARB, latitude, WDB_SONIC, RN_UW_VWB_cov, TAU_QCB)
        Call Data_Quality_SSITC_wo_WndDir_Momentum (Planar_Fit_flg, ZLB, UB_SIGMA, WB_SIGMA, USTARB, latitude,RN_UW_VWB_cov, TAU_SSITC_TESTB)
        '*** End of data quality classification for momentum flux ***
        '*** Data quality classification for scalar fluxes ***
        'Sensible heat flux
        'Calculate the measures of relative non-stationarity (Steady State Test)
        RN_WTB_SONIC_cov  = ABS((RN_WTB_SONIC_cov/nmbr_interval_qc_csatB - WTB_SONIC_Cov)/WTB_SONIC_Cov)                                              'in fraction
        Call Data_Quality_SSITC_w_WndDir_Scalar  (ZLB, WB_SIGMA, USTARB, TB_SONIC_SIGMA, TSTARB, latitude, WDB_SONIC, RN_WTB_SONIC_cov, H_QCB)           'Quality classification for sensible heat flux w/ considering wind direction
        Call Data_Quality_SSITC_wo_WndDir_Scalar (ZLB, WB_SIGMA, USTARB, TB_SONIC_SIGMA, TSTARB, latitude, RN_WTB_SONIC_cov, H_SSITC_TESTB   'Quality classification for sensible heat flux w/o considering wind direction
        RN_WTB_SONIC_cov = 0.0
        nmbr_interval_qc_csatB = 0.0

        'Calculate planetary boundary layer height
        Call Planetary_Boundary_Layer_Height(MO_LENGTHB, PBLHB)
      #EndIf

      '*** End of CSAT sonic head processing ***

      CallTable stats_net_radiation

      'Get Rn for the current averaging interval ***
      If (stats_net_radiation.Output(1,1)) Then

        GetRecord (NETRAD, stats_net_radiation, 1)

      EndIf
      CallTable stats_tmpr_rh

      If (stats_tmpr_rh.Output(1, 1)) Then
        GetRecord (stats_out_tmpr_rh(1), stats_tmpr_rh, 1)
      EndIf

      'Save time series data.
      CallTable Time_Series
      #If CSAT3B_B Then
        CallTable Time_SeriesB
      #EndIf

      'Save averaged and calculated data.
      'CallTable Flux_AmeriFluxFormat

      CallTable Flux_CSFormat
      #If CSAT3B_B Then
        CallTable FluxB_CSFormat
      #EndIf

      CallTable Flux_Notes
      #If CSAT3B_B Then
        CallTable FluxB_Notes
      #EndIf

      'The ending time stamp in current interval is the starting time stamp for next interval
      TIMESTAMP_START = TIMESTAMP_END
      Erase(TIMESTAMP_END)

      '*** End of Checking how many days left for data storage in MicroSD ****

      slowsequence_disable_f = TRUE
      If (slowsequence_finished_f) Then
        slowsequence_finished_f = FALSE
        slowsequence_disable_f  = FALSE
      EndIf
    Else
      scan_count += 1
    EndIf

  NextScan
  '**********************************************************************************************************************************************

  SlowSequence

  Scan (SLW_SCN_INTV, mSec, 3, 0)

    'Measure battery voltage.
    Battery (batt_volt)

    'Measure CR6 panel temperature
    PanelTemp (panel_tmpr, NTCH_FRQ_SLW)

    process_time = (Status.ProcessTime(1,1))/1000.0                              'in ms
    buff_depth   = Status.BuffDepth(1,1)

    CallTable diagnostic
    CallTable diagnosticB

    '*** Beginning of net radiation measurements ***

    #If SENSOR_CNR4 Then
      '*** Beginning of a 4-way radiometer measurements ***
      VoltSe( R_SW_in, 4, mV200,U9,False, 500, NTCH_FRQ_SLW, 1, 0)
      'Compute net radiation, albedo, downwelling and upwelling long-wave radiation.
      R_SW_in       = R_SW_in*SW_IN_CAL
      'SW_IN         = R_SW_in                                               'for use of the same variable in AmeriFlux format for SW incoming radiation from different sensors
      R_SW_out      = R_SW_out*SW_OUT_CAL
      'SW_OUT = R_SW_out
      R_LW_in_meas  = R_LW_in*LW_IN_CAL
      R_LW_out_meas = R_LW_out*LW_OUT_CAL
      NETRAD_raw = R_SW_in - R_SW_out + R_LW_in_meas - R_LW_out_meas

      'NR01 or CNR4: Smallest sensitivity is 10 uV/(W/m^2), CR6 resolution at the measurement range (+/-200 mV) is 0.1 uV.
      'Radiation < 0.01 W/m^2 can not be resolved by CR6. The value of 1.0 is used for this threshold although this is approximation.
      If (R_SW_in > 1.0) AND (R_SW_in >= R_SW_out) Then
        albedo = 100.0*(R_SW_out/R_SW_in)
        ' ALB = albedo                 'in %
      Else
        albedo = 0.0
      EndIf

      'Correct longwave radiation.
      BrHalf (X_cnr4,1,mV1000,U7,U8,1,1000,True ,500,50,1.0,0)
      ln_R = LOG (1000.0*X_cnr4/(1-X_cnr4))
      T_nr = (1/(A_SHH+B_SHH*ln_R+C_SHH*ln_R*ln_R*ln_R))
      R_LW_in  = R_LW_in_meas  + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
      R_LW_out = R_LW_out_meas + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
      'LW_IN = R_LW_in
      'LW_OUT = R_LW_out
      'NETRAD = R_SW_in - R_SW_out + R_LW_in - R_LW_out

      '*** End of a 4-way radiometer measurements ***
    #EndIf

    '*** Beginning of temperature and humidity probe measurements **
    #If SENSOR_T107 Then
      Therm107 (T107_probe,1,U3,U4,0,50,1.0,0)
      T107_probe = T107_probe + T107PR_OFST
    #EndIf

    #If SENSOR_T_RH Then
      SDI12Recorder (T_probe,C3,1,"M!",1.0,0)
      T_probe  = T_probe*TMPR_MULT + TMPR_OFST
      RH_probe = RH_probe*RH_MULT + RH_OFST
    #EndIf
    '*** End of temperature and humidity probe measurements ***

    #If Sensor_CS100 Then
      '*** ambient pressure CS100, kPa
      VoltSe (amb_press,1,mV5000,U1,False,200,50,0.02,60)  ' kPa
    #EndIf

    '*** NTC Ice Temp****
    ' *** Beginning of CDM-A116 panel temperature measurement ***
    CDM_PanelTemp (CDM_A116, CPI_ADDR_CDM, panel_tmpr_CDM_A116_1, 1, 1, FIRST_NOTCH_FREQ_MAIN_SCAN)
    '*** End of CDM-A116 panel temperature measurement ***
    #If SENSOR_Icetemp_JB1
      CDM_Therm107 (CDM_A116,CPI_ADDR_CDM,Tice(1),8,1,X1,1000,50,1.0,Tice_OFST(1))
    #EndIf
    #If SENSOR_Icetemp_JB2 Then
      CDM_Therm107 (CDM_A116,CPI_ADDR_CDM,Tice(9),8,9,X2,1000,50,1.0,Tice_OFST(9))
    #EndIf

    '*** snow height SR50***
    #If SENSOR_SR50a Then
      SDI12Recorder(HSmeas,C3,0,"M1!",100,0,-1)

      ' calculation of snow depth 1 with temperature compensation
      HSact  = SHM_H - HSmeas*(SQR((T107_probe+273.15)/273.15))
      If (HSmeas < 30) OR (HSmeas > 500) OR HSmeas = NAN Then HSact = NAN
    #EndIf

    #If SENSOR_23S Then
      VoltSe (WaterPress23s,1,mV5000,U2,False,200,50,0.0032,0)
    #EndIf

    #If Sensor_CS100 AND SENSOR_T107 AND SENSOR_T_RH Then
      '*** Beginning of temperature and humidity probe processing ***
      'Saturation water pressure at current temperature
      Enhance_factor1_probe = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(T_probe + 30.6 - 0.38*amb_press)^2.0)     'Eq. 6 from Appendix A of flux program manual

      Select Case T107_probe                                                                                   'Eq. 5 from Appendix A of flux program manual
      Case Is >= 0
        e_sat_probe = 0.61121*Enhance_factor1_probe*EXP((17.368*T107_probe)/(T107_probe + 238.88))
      Case Is < 0
        e_sat_probe = 0.61121*Enhance_factor1_probe*EXP((17.966*T107_probe)/(T107_probe + 247.15))
      EndSelect

      e_probe = (RH_probe*e_sat_probe)/100

      H2O_probe   = e_probe/((T107_probe + T_0C_K)*Rv)                        'g/m^3
      rho_d_probe = (amb_press - e_probe)/((T107_probe + T_0C_K)*Rd)          'g/m^3
      rho_a_probe = H2O_probe + rho_d_probe
      'Dew point temperature for general use for accurately computing the final dew point temperature
      Enhance_factor2_probe = 1.00072 + (3.46e-5)*amb_press                                                       'Eq. 9 from Appendix A of flux program manual

      x_tmp_probe           = LN(e_probe/(0.61121*Enhance_factor2_probe))                                         'For dew point temperature, assume that e is saturation water vapor pressure
      Td_gp_probe           = 240.97*x_tmp_probe/(17.502-x_tmp_probe)

      'Accurate dew point temperature
      Enhance_factor1_probe  = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Td_gp_probe + 30.6 - 0.38*amb_press)^2.0)  'Eq. 6 from Appendix A of flux program manual

      x_tmp_probe            = LN(e_probe/(0.61121*Enhance_factor1_probe))                                       'For dew point temperature, assume that e is saturation water vapor pressure

      Select Case Td_gp_probe                                                                                    'Eq. 11 from Appendix A of flux program manual
      Case Is >= 0
        T_DP_Probe = (238.88*x_tmp_probe)/(17.368 - x_tmp_probe)
      Case Is < 0
        T_DP_Probe = (247.15*x_tmp_probe)/(17.966 - x_tmp_probe)
      EndSelect

      'Momentum flux after coordinate rotation and frequency corrections
      TAU = rho_a_probe_Avg*USTAR*USTAR                                                    'eq. (9.14), page 384 (Wallace and Hobbs (2006)

      'Correct sonic temperature flux for humidity and calculate sensible heat flux
      'WT_SONIC_Cov_fc_SND = WT_SONIC_Cov_fc*(1- 0.51*(H2O_probe/(1e3*rho_a_probe)))-0.51*(T_SONIC + T_0C_K)*WH2O_Cov_fc/(1e3*rho_a_probe)     'eq. 2.53 in van Dijk (2002)
      Treal = T_SONIC / (1+ 0.51*(H2O_probe_Avg/(1e3*rho_a_probe_Avg)))
      WT_SONIC_Cov_fc_SND = WT_SONIC_Cov_fc / (1+ 0.51*(H2O_probe_Avg/(1e3*rho_a_probe_Avg)))
      Cp = (Cpd*rho_d_probe + Cpw*H2O_probe)/(rho_d_probe_Avg + H2O_probe_Avg)   'Specific heat of moist air
      H  = Cp*rho_a_probe*WT_SONIC_Cov_fc_SND

      #If CSAT3B_B Then
        'Momentum flux after coordinate rotation and frequency corrections
        TAUB = rho_a_probe_Avg*USTARB*USTARB                                                    'eq. (9.14), page 384 (Wallace and Hobbs (2006)

        'Correct sonic temperature flux for humidity and calculate sensible heat flux
        'WT_SONIC_Cov_fc_SND = WT_SONIC_Cov_fc*(1- 0.51*(H2O_probe/(1e3*rho_a_probe)))-0.51*(T_SONIC + T_0C_K)*WH2O_Cov_fc/(1e3*rho_a_probe)     'eq. 2.53 in van Dijk (2002)
        Treal = TB_SONIC / (1+ 0.51*(H2O_probe_Avg/(1e3*rho_a_probe_Avg)))
        WTB_SONIC_Cov_fc_SND = WTB_SONIC_Cov_fc / (1+ 0.51*(H2O_probe_Avg/(1e3*rho_a_probe_Avg)))
        'Cp = (Cpd*rho_d_probe + Cpw*H2O_probe)/(rho_d_probe_Avg + H2O_probe_Avg)   'Specific heat of moist air
        HB  = Cp*rho_a_probe*WTB_SONIC_Cov_fc_SND
        TSTARB = - WTB_SONIC_Cov_fc_SND/USTARB
      #EndIf
      TSTAR = - WT_SONIC_Cov_fc_SND/USTAR
    #EndIf

    'Calculate solar position
    RealTime(realtime_array(1))
    SolarPosition(solar_position_array(1), realtime_array(1), UTC_OFST*3600, latitude, longitude, altitude, 10*amb_press, T107_probe)
    hour_angle      = 180.0*hour_angle/PI                                                      'Radians to degrees
    sun_declination = 180.0*sun_declination/PI                                                 'Radians to degrees

    If (sun_elevation > 0) Then
      daytime = 1
      daytime_frac_scan_intv = SCAN_INTERVAL_WEIGHT
    Else
      daytime = 0
      daytime_frac_scan_intv = 0
    EndIf

    '*** Updating files of station variables and planar fit angles ***

    For i_slow = 1 To NMBR_STN_VAR

      If  (stn_conf_array_prev(i_slow) <> stn_conf_array(i_slow)) Then

        Select Case i_slow
          'Update the pointing direction of CSAT
        Case 1
          If ((sonic_azimuth < 0.0) OR (sonic_azimuth > 360.0)) Then
            sonic_azimuth = stn_conf_array_prev(1)             'Set back to previous value
          EndIf

          'Update geo-coordinates
        Case 2
          If (ABS(latitude) > 90.0) Then
            latitude = stn_conf_array_prev(2)                   'Set back to previous value
          EndIf

        Case 3
          If (hemisphere_NS = NORTH) Then
            latitude = ABS(latitude)
          Else
            latitude = - ABS(latitude)
          EndIf

        Case 4
          If (ABS(longitude) > 180.0) Then
            longitude = stn_conf_array_prev(4)                   'Set back to previous value
          EndIf

        Case 5
          If (hemisphere_EW = EAST) Then
            longitude = ABS(longitude)
          Else
            longitude = -ABS(longitude)
          EndIf

        Case 6
          If ((altitude > 8000.0) OR (altitude < -1000.0))  Then
            altitude = stn_conf_array_prev(6)                   'Set back to previous value
          EndIf

          ' Update Aerodynamic height (z)
        Case 7, 8, 9, 10, 11
          If ((height_measurement > 250.0) OR (height_measurement < 0.2)) Then
            height_measurement = stn_conf_array_prev(7)         'Set back to  previous value
          EndIf

          If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND ((height_measurement > 100 OR height_measurement < 0.2))) Then
            height_measurement = stn_conf_array_prev(7)          'Set back to previous value
          EndIf

          If ((surface_type = FOREST) AND ((height_measurement > 250.0) OR (height_measurement < 0.2))) Then
            height_measurement = stn_conf_array_prev(7)          'Set back to previous value
          EndIf

          If ((surface_type < CROP) OR (surface_type > ICE)) Then
            surface_type = stn_conf_array_prev(8)
          EndIf

          If ((surface_type = BARELAND) OR (surface_type = WATER) OR (surface_type = ICE)) Then
            height_canopy = 0                                   'Set back to default value
          EndIf

          If (((surface_type = CROP) OR (surface_type = GRASS) OR (surface_type = SHRUB)) AND (height_canopy > 15)) Then
            height_canopy = stn_conf_array_prev(9)               'Set back to previous value
          EndIf

          If ((surface_type = FOREST ) AND (height_canopy > 100.0)) Then
            height_canopy = stn_conf_array_prev(9)               'Set back to previous value
          EndIf

          If (displacement_user > height_measurement) OR (displacement_user < 0.0) Then
            displacement_user = stn_conf_array_prev(10)
          EndIf

          If (roughness_user > height_measurement) OR (roughness_user < 0.0) Then
            roughness_user = stn_conf_array_prev(11)
          EndIf

          Call Displacement_roughness_heights (surface_type, displacement_user, roughness_user, height_canopy, height_measurement, d, z0, z)
          surface_type_text = surface_type_array(surface_type)

          For i_slow = 14 To 17
            If (stn_conf_array(i_slow) = 100.0*z_prev) Then
              stn_conf_array(i_slow) = 100.0*z                 'Default value of 100*z for all sectors in different directions
            EndIf
          Next

        Case 14, 15, 16, 17
          If ((stn_conf_array (i_slow) > 5000) OR (stn_conf_array (i_slow) < 0)) Then
            stn_conf_array (i_slow) = stn_conf_array_prev (i_slow)                          'Set back to previous value
          EndIf
        EndSelect

        Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:stn_conf_array.dat", 0)               'Store the new values to the file.
        Move(stn_conf_array_prev(1), NMBR_STN_VAR , stn_conf_array(1), NMBR_STN_VAR)         'Update stn_conf_array_prev()
        ExitFor
      EndIf '(stn_conf_array_prev(i_slow) <> stn_conf_array(i_slow))
    Next i_slow

    #If CSAT3B_B Then

      For i_slow = 1 To NMBR_STN_VAR

        If  (stnB_conf_array_prev(i_slow) <> stnB_conf_array(i_slow)) Then

          Select Case i_slow
            'Update the pointing direction of CSAT
          Case 1
            If ((sonic_azimuthB < 0.0) OR (sonic_azimuthB > 360.0)) Then
              sonic_azimuthB = stnB_conf_array_prev(1)             'Set back to previous value
            EndIf

            'Update geo-coordinates
          Case 2
            If (ABS(latitudeB) > 90.0) Then
              latitudeB = stnB_conf_array_prev(2)                   'Set back to previous value
            EndIf

          Case 3
            If (hemisphere_NSB = NORTH) Then
              latitudeB = ABS(latitudeB)
            Else
              latitudeB = - ABS(latitudeB)
            EndIf

          Case 4
            If (ABS(longitudeB) > 180.0) Then
              longitudeB = stnB_conf_array_prev(4)                   'Set back to previous value
            EndIf

          Case 5
            If (hemisphere_EWB = EAST) Then
              longitudeB = ABS(longitudeB)
            Else
              longitudeB = -ABS(longitudeB)
            EndIf

          Case 6
            If ((altitudeB > 8000.0) OR (altitudeB < -1000.0))  Then
              altitudeB = stnB_conf_array_prev(6)                   'Set back to previous value
            EndIf

            ' Update Aerodynamic height (z)
          Case 7, 8, 9, 10, 11
            If ((height_measurementB > 100.0) OR (height_measurementB < 0.2)) Then
              height_measurementB = stnB_conf_array_prev(7)         'Set back to  previous value
            EndIf

            If (((surface_typeB = CROP) OR (surface_typeB = GRASS) OR (surface_typeB = SHRUB)) AND ((height_measurementB > 5 OR height_measurementB < 0.2))) Then
              height_measurementB = stnB_conf_array_prev(7)          'Set back to previous value
            EndIf

            If ((surface_typeB = FOREST) AND ((height_measurementB > 500.0) OR (height_measurementB < 0.2))) Then
              height_measurementB = stnB_conf_array_prev(7)          'Set back to previous value
            EndIf

            If ((surface_typeB < CROP) OR (surface_typeB > ICE)) Then
              surface_typeB = stnB_conf_array_prev(8)
            EndIf

            If ((surface_typeB = BARELAND) OR (surface_typeB = WATER) OR (surface_typeB = ICE)) Then
              height_canopyB = 0                                   'Set back to default value
            EndIf

            If (((surface_typeB = CROP) OR (surface_typeB = GRASS) OR (surface_typeB = SHRUB)) AND (height_canopyB > 15)) Then
              height_canopyB = stnB_conf_array_prev(9)               'Set back to previous value
            EndIf

            If ((surface_typeB = FOREST ) AND (height_canopyB > 100.0)) Then
              height_canopyB = stnB_conf_array_prev(9)               'Set back to previous value
            EndIf

            If (displacement_userB > height_measurementB) OR (displacement_userB < 0.0) Then
              displacement_userB = stnB_conf_array_prev(10)
            EndIf

            If (roughness_userB > height_measurementB) OR (roughness_userB < 0.0) Then
              roughness_userB = stnB_conf_array_prev(11)
            EndIf

            Call Displacement_roughness_heights (surface_typeB, displacement_userB, roughness_userB, height_canopyB, height_measurementB, dB, z0B, zB)
            surface_type_text = surface_type_array(surface_type)

            For i_slow = 14 To 17
              If (stnB_conf_array(i_slow) = 100.0*zB_prev) Then
                stnB_conf_array(i_slow) = 100.0*zB                 'Default value of 100*z for all sectors in different directions
              EndIf
            Next

          Case 14, 15, 16, 17
            If ((stnB_conf_array (i_slow) > 5000) OR (stnB_conf_array (i_slow) < 0)) Then
              stnB_conf_array (i_slow) = stnB_conf_array_prev (i_slow)                          'Set back to previous value
            EndIf
          EndSelect

          Calfile (stnB_conf_array(1), NMBR_STN_VAR, "CPU:stnB_conf_array.dat", 0)               'Store the new values to the file.
          Move(stnB_conf_array_prev(1), NMBR_STN_VAR , stnB_conf_array(1), NMBR_STN_VAR)         'Update stn_conf_array_prev()
          ExitFor
        EndIf '(stn_conf_array_prev(i_slow) <> stn_conf_array(i_slow))
      Next i_slow
    #EndIf

    '*** Estimate the days of MicroSD for more data storage ***
    If (card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") Then
      '1000 connverts mSecond to Second, 24 hours/day, and 3600 seconds/hour
      card_storage_available_days = card_storage_available_days - (SLW_SCN_INTV/1000)/(24*3600)

      '*** Time_Series files
      'Normal computation
      days_actv_tbl_Time_Series = days_actv_tbl_Time_Series - (SLW_SCN_INTV/1000)/(24*3600)
      days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series

      'Computation immedately after file normal closing
      If ((LastFileName_Time_Series <> LastFileName_Time_Series_prev) AND (realtime_array(4)= 0)) Then
        card_bytes_free           = Status.CardBytesFree                                 'in bytes.
        card_bytes_free_assgnd    = card_bytes_free_assgnd    - bytes_tbl_Time_Series
        days_actv_tbl_Time_Series = DAY_TSRS_CRD
        days_more_tbl_Time_Series = days_more_tbl_Time_Series - DAY_TSRS_CRD
        days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series

        LastFileName_Time_Series_prev = LastFileName_Time_Series
      EndIf

      '*** Flux files
      'Normal computation
      days_actv_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes - (SLW_SCN_INTV/1000)/(24*3600)
      days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes

      'Computation immedately after file normal closing
      If ((LastFileName_flux_CSFormat <> LastFileName_flux_CSFormat_prev) AND (realtime_array(4) = 0)) Then
        card_bytes_free           = Status.CardBytesFree                                  'in bytes.
        card_bytes_free_assgnd    = card_bytes_free_assgnd - bytes_tbl_flux_CSFormat

        days_actv_tbl_flux_CSFormat_notes = DAY_FLUX_CRD
        days_more_tbl_flux_CSFormat_notes = days_more_tbl_flux_CSFormat_notes - DAY_FLUX_CRD
        days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes

        LastFileName_flux_CSFormat_prev = LastFileName_flux_CSFormat

      EndIf

    Else
      days_actv_tbl_Time_Series          = NaN
      days_more_tbl_Time_Series          = NaN
      days_totl_tbl_Time_Series          = NaN

      days_actv_tbl_flux_CSFormat_notes = NaN
      days_more_tbl_flux_CSFormat_notes = NaN
      days_totl_tbl_flux_CSFormat_notes = NaN

      card_storage_available_days       = NaN

    EndIf



    'Computaion immediately after MicrSD is replaced
    If ((card_storage_available_days = NaN) AND (Status.CardStatus = "Card OK.")) Then

      're-estimate card_storage_available_days
      card_bytes_free = Status.CardBytesFree                               'in bytes.

      If (card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.") Then

        day_snc_0101_1990 = SecsSince1990(status.TimeStamp(1,1), 1)/(24*3600)

        days_actv_tbl_Time_Series = DAY_TSRS_CRD - (day_snc_0101_1990 MOD DAY_TSRS_CRD)

        'Pre-set, assume no extra storage in MicroSD
        days_totl_tbl_Time_Series = days_actv_tbl_Time_Series

        days_actv_tbl_flux_CSFormat_notes = DAY_FLUX_CRD - (day_snc_0101_1990 MOD DAY_FLUX_CRD)

        'Pre-set, assume no extra storage in MicroSD
        days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes

        'Flux_AmeriFluxFormat is not pre-allocated, but used the same DAY_FLUX_CRD as Flux_CSFormat and Flux_Notes ues.
        'The bytes used within days_actv_tbl_flux_CSFormat are included in card_bytes_free, which should be considered as assigned bytes.
        ' card_bytes_free_assgnd = (days_actv_tbl_flux_CSFormat_notes/DAY_FLUX_CRD)*bytes_tbl_AmeriFluxFormat


        card_bytes_free_unassgnd   = card_bytes_free - card_bytes_free_assgnd
        days_more_tbl_Time_Series = 0                                            'Reset after MicroSD abnormal including the replacement of MicroSD


        days_more_tbl_flux_CSFormat_notes = 0                               'Reset after MicroSD abnormal including the replacement of MicroSD

        While (((days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) AND (card_bytes_free_unassgnd > bytes_tbl_Time_Series)) OR ((days_totl_tbl_flux_CSFormat_notes < days_totl_tbl_Time_Series)  AND (card_bytes_free_unassgnd > (bytes_tbl_flux_CSFormat + bytes_tbl_flux_notes))))

          If (days_totl_tbl_flux_CSFormat_notes >= days_totl_tbl_Time_Series) Then
            card_bytes_free_assgnd    = card_bytes_free_assgnd    + bytes_tbl_Time_Series
            days_more_tbl_Time_Series = days_more_tbl_Time_Series + DAY_TSRS_CRD
            days_totl_tbl_Time_Series = days_actv_tbl_Time_Series + days_more_tbl_Time_Series

          Else
            card_bytes_free_assgnd            = card_bytes_free_assgnd + bytes_tbl_flux_CSFormat  + bytes_tbl_flux_notes
            days_more_tbl_flux_CSFormat_notes = days_more_tbl_flux_CSFormat_notes + DAY_FLUX_CRD
            days_totl_tbl_flux_CSFormat_notes = days_actv_tbl_flux_CSFormat_notes + days_more_tbl_flux_CSFormat_notes

          EndIf

          card_bytes_free_unassgnd  = card_bytes_free - card_bytes_free_assgnd

        Wend

        If (days_totl_tbl_Time_Series >= days_totl_tbl_flux_CSFormat_notes) Then
          card_storage_available_days = days_totl_tbl_flux_CSFormat_notes
        Else
          card_storage_available_days = days_totl_tbl_Time_Series
        EndIf

        LastFileName_Time_Series_prev   = LastFileName_Time_Series
        LastFileName_flux_CSFormat_prev = LastFileName_flux_CSFormat

      Else
        days_actv_tbl_Time_Series          = NaN
        days_more_tbl_Time_Series          = NaN
        days_totl_tbl_Time_Series          = NaN

        days_actv_tbl_flux_CSFormat_notes = NaN
        days_more_tbl_flux_CSFormat_notes = NaN
        days_totl_tbl_flux_CSFormat_notes = NaN

        card_storage_available_days       = NaN

      EndIf '(card_bytes_free >= 0) AND (Status.CardStatus = "Card OK.")

    EndIf '((card_storage_available_days = NaN) AND (Status.CardStatus = "Card OK."))
    '*** End of Checking how many days left for data storage in MicroSD ****

    slowsequence_finished_f = TRUE
  NextScan
EndProg
